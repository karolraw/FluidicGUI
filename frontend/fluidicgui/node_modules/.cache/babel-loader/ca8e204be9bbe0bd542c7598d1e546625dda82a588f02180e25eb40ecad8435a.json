{"ast":null,"code":"var _jsxFileName = \"E:\\\\flow chemistry\\\\fluidicGUI\\\\frontend\\\\fluidicgui\\\\src\\\\components\\\\Simulation\\\\Simulation.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useCallback, useRef } from 'react';\nimport PumpActions from './NodeActions/PumpActions';\nimport DraggablePanel from './DraggablePanel';\nimport { convertToHardwareValuesPump } from '../../utils/pumpCalculations';\nimport { useButtonStyles } from '../../styles/ButtonStyleProvider';\nimport { backgroundVariants } from '../../styles/backgroundStyles';\nimport { findOutletNode, findFurthestNode, orderNodesByDistance, calculateEdgeVolume, getVolumeBetweenNodes, findConnectedPump, getPumpSpeed, getPumpsBetweenPositions, cleanAndSortEventList, getPumpSpeedAtTime, sendEventsToDevices, setOfMainLineNodes, setOfSecondaryLineNodes } from '../../utils/simulationUtils';\nimport './simulation.css'; // We'll create this CSS file\nimport SvgDefs from './SvgDefs';\nimport { calculateEdgePoints, createLabels } from '../../utils/flowchartUtils';\nimport USBSpectrometer from './USBSpectrometer';\nimport SpectrometerMQTT from './SpectrometerMQTT';\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst Simulation = ({\n  nodes = [],\n  edges = [],\n  droplets = [],\n  selectedCarrierPumps = [],\n  onBack,\n  onNext\n}) => {\n  _s();\n  var _dropletHistory$curre, _selectedNode$data, _selectedNode$data2, _selectedNode$data3;\n  const buttonVariants = useButtonStyles();\n  const [graphData, setGraphData] = useState({\n    nodes: [],\n    links: []\n  });\n  const [simulationDroplets, setSimulationDroplets] = useState([]);\n  const [isSimulationRunning, setIsSimulationRunning] = useState(false);\n  const [key, setKey] = useState(0);\n  const [currentTime, setCurrentTime] = useState(0);\n  const [timeScale, setTimeScale] = useState(1); // Default 1x speed\n  const animationFrameRef = useRef();\n  const lastFrameTimeRef = useRef();\n  const [currentBlockDroplets, setCurrentBlockDroplets] = useState([]);\n  const [dropletHistory, setDropletHistory] = useState([]);\n  const [currentTimepoint, setCurrentTimepoint] = useState(0);\n  const [pumpEvents, setPumpEvents] = useState([]);\n  const [displayPumpSpeeds, setDisplayPumpSpeeds] = useState(false);\n  const [displayNodeIds, setDisplayNodeIds] = useState(false);\n  const [displayDropletInfo, setDisplayDropletInfo] = useState(false);\n  const [displayDropletGaps, setDisplayDropletGaps] = useState(true);\n  const [displayEdgeLabels, setDisplayEdgeLabels] = useState(false);\n  const [isDisplayMenuOpen, setDisplayMenuOpen] = useState(false);\n  const [displayTimelineDropletInfo, setDisplayTimelineDropletInfo] = useState(false);\n  const displayMenuRef = useRef(null);\n  const [selectedNode, setSelectedNode] = useState(null);\n  const [ws, setWs] = useState(null);\n  const [pumpPanelPosition, setPumpPanelPosition] = useState({\n    x: window.innerWidth - 300,\n    y: 100\n  });\n  const [visiblePumpPanel, setVisiblePumpPanel] = useState(null);\n\n  // Add at the beginning of the component, after the state initialization\n  useEffect(() => {\n    // Log all nodes and their types for debugging\n    console.log('All nodes:', nodes);\n    if (nodes && nodes.length > 0) {\n      console.log('Node types in simulation:', nodes.map(node => {\n        var _node$data;\n        return {\n          id: node.id,\n          type: node.type,\n          dataType: (_node$data = node.data) === null || _node$data === void 0 ? void 0 : _node$data.type\n        };\n      }));\n    }\n  }, [nodes]);\n  useEffect(() => {\n    // Create WebSocket connection\n    const websocket = new WebSocket('ws://localhost:4000');\n    websocket.onopen = () => {\n      console.log('Connected to WebSocket server');\n    };\n    websocket.onerror = error => {\n      console.error('WebSocket error:', error);\n    };\n    setWs(websocket);\n\n    // Cleanup on unmount\n    return () => {\n      if (websocket) {\n        websocket.close();\n      }\n    };\n  }, []);\n  const sendingEventsToDevices = () => {\n    sendEventsToDevices(pumpEvents, ws, nodes);\n    // Reset simulation state\n    setCurrentTime(0);\n    setCurrentTimepoint(0);\n    setIsSimulationRunning(true);\n    setDropletHistory([]);\n    // Generate new event list\n    generateEventList([{\n      droplets: droplets\n    }]);\n  };\n  const eventType = ['setPumpSpeed', 'setThermostatTemperature', 'setLedIntensity', 'wait', 'blockEnd'];\n  const calculateVolumesBetweenThermostats = graphData => {\n    // Find outlet node first\n    const outletNode = findOutletNode(graphData.nodes);\n    const visited = new Set();\n    const queue = [[outletNode.id, 0, []]]; // [nodeId, accumulated volume, path of thermostats]\n    const thermostatVolumes = [];\n    while (queue.length > 0) {\n      let [currentNodeId, accumulatedVolume, thermostatPath] = queue.shift();\n      const currentNode = graphData.nodes.find(n => n.id === currentNodeId);\n      if (!currentNode) continue;\n\n      // Track all visited nodes to prevent infinite loops\n      if (visited.has(currentNodeId)) continue;\n      visited.add(currentNodeId);\n\n      // If we found a thermostat, add it to the path\n      let updatedPath = [...thermostatPath];\n      if (currentNode.type === 'thermostat') {\n        if (thermostatPath.length > 0) {\n          thermostatVolumes.push({\n            startThermostatId: thermostatPath[thermostatPath.length - 1],\n            endThermostatId: currentNodeId,\n            volume: accumulatedVolume\n          });\n        }\n        updatedPath.push(currentNodeId);\n        // Reset accumulated volume after finding a thermostat\n        accumulatedVolume = 0;\n      }\n\n      // Find all connected edges and nodes\n      const connectedEdges = graphData.links.filter(link => link.source === currentNodeId || link.target === currentNodeId);\n      for (const edge of connectedEdges) {\n        const nextNodeId = edge.source === currentNodeId ? edge.target : edge.source;\n        const nextNode = graphData.nodes.find(n => n.id === nextNodeId);\n\n        // Skip paths to pumps\n        if (nextNode && nextNode.type !== 'pump') {\n          const edgeVolume = calculateEdgeVolume(edge);\n          queue.push([nextNodeId, accumulatedVolume + edgeVolume, updatedPath]);\n        }\n      }\n    }\n    return thermostatVolumes;\n  };\n  //add something to handle lack of thermostat\n  const divideDropletsIntoBlocks = (droplets, thermostatVolumes) => {\n    if (thermostatVolumes.length === 0) {\n      return [{\n        droplets: droplets,\n        thermostatId: null,\n        totalVolume: droplets.reduce((acc, droplet) => acc + droplet.actualVolume, 0),\n        temperature: null,\n        time: null\n      }];\n    }\n    const furthestNode = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links);\n    const volumeToFurthestNode = getVolumeBetweenNodes(thermostatVolumes[0].endThermostatId, furthestNode.id, graphData.nodes, graphData.links);\n    if (!droplets.length || !thermostatVolumes.length) return [];\n    const blocks = [];\n    let currentBlock = {\n      droplets: [],\n      thermostatId: thermostatVolumes[0].endThermostatId,\n      totalVolume: 0,\n      temperature: null,\n      time: null\n    };\n\n    // Helper to finalize a block and start a new one\n    const finalizeBlock = (thermostatId, temperature, time) => {\n      if (currentBlock.droplets.length > 0) {\n        // Add volumeToFurthestNode to the surfixVolume of the last droplet in the block\n        const lastDroplet = currentBlock.droplets[currentBlock.droplets.length - 1];\n        const surfixParam = lastDroplet.parameters.find(p => p.name === 'surfixVolume');\n        if (surfixParam) {\n          surfixParam.value = Math.max(volumeToFurthestNode, surfixParam.value);\n        } else {\n          lastDroplet.parameters.push({\n            name: 'surfixVolume',\n            value: volumeToFurthestNode\n          });\n        }\n        blocks.push({\n          ...currentBlock\n        });\n      }\n      currentBlock = {\n        droplets: [],\n        thermostatId: thermostatId,\n        totalVolume: 0,\n        temperature: temperature,\n        time: time\n      };\n    };\n\n    // Process droplets in order\n    for (let i = 0; i < droplets.length; i++) {\n      var _droplet$parameters$f, _droplet$parameters$f2, _droplet$parameters$f3, _droplet$parameters$f4, _droplet$parameters$f5;\n      const droplet = droplets[i];\n      const temperature = (_droplet$parameters$f = droplet.parameters.find(p => p.name === 'temperature')) === null || _droplet$parameters$f === void 0 ? void 0 : _droplet$parameters$f.value;\n      const time = (_droplet$parameters$f2 = droplet.parameters.find(p => p.name === 'time')) === null || _droplet$parameters$f2 === void 0 ? void 0 : _droplet$parameters$f2.value;\n\n      // Start new block if temperature or time changes, or if volume limit exceeded\n      const relevantVolume = thermostatVolumes.find(tv => tv.startThermostatId === currentBlock.thermostatId || tv.endThermostatId === currentBlock.thermostatId);\n      let dropletVolume = (_droplet$parameters$f3 = droplet.parameters.find(p => p.name === 'volume')) === null || _droplet$parameters$f3 === void 0 ? void 0 : _droplet$parameters$f3.value;\n      dropletVolume += (_droplet$parameters$f4 = droplet.parameters.find(p => p.name === 'prefixVolume')) === null || _droplet$parameters$f4 === void 0 ? void 0 : _droplet$parameters$f4.value;\n      if (currentBlock.temperature !== temperature || currentBlock.time !== time || relevantVolume && currentBlock.totalVolume + dropletVolume > relevantVolume.volume) {\n        finalizeBlock(thermostatVolumes[0].endThermostatId, temperature, time);\n      }\n      dropletVolume += (_droplet$parameters$f5 = droplet.parameters.find(p => p.name === 'surfixVolume')) === null || _droplet$parameters$f5 === void 0 ? void 0 : _droplet$parameters$f5.value;\n      // Add droplet to current block\n      currentBlock.droplets.push(droplet);\n      currentBlock.totalVolume += dropletVolume;\n      currentBlock.temperature = temperature;\n      currentBlock.time = time;\n    }\n\n    // Finalize last block\n    finalizeBlock(null, null, null);\n    return blocks;\n  };\n  function printDropletFrontPositionsAndSpeeds(droplets) {\n    droplets.forEach(droplet => {\n      console.log(`Droplet ID: ${droplet.id}, Front Volumetric Position: ${droplet.frontVolumetricPosition}, Front time to next node  : ${droplet.frontTimeToReachNextNode}, Front Volumetric Distance to next node: ${droplet.frontVolumetricDistanceToNextNode}, Rear Volumetric Position: ${droplet.rearVolumetricPosition}, Rear time to next node: ${droplet.rearTimeToReachNextNode}, Rear Volumetric Distance to next node: ${droplet.rearVolumetricDistanceToNextNode}, frontNextNodeID: ${droplet.frontNextNodeID}, rearNextNodeID: ${droplet.rearNextNodeID}`);\n    });\n  }\n  const extractPumpEvents = eventList => {\n    // eventList is now an array of arrays, where each inner array contains events for a specific pump\n    return eventList.flat() // Flatten the array of arrays\n    .filter(event => event.type === 'setPumpSpeed').sort((a, b) => a.time - b.time);\n  };\n  const recalculateEventListForDevices = eventList => {\n    const deviceEventMap = new Map();\n    const convertPumpEvent = (event, deviceProperties) => {\n      var _deviceProperties$fin, _deviceProperties$fin2, _deviceProperties$fin3, _deviceProperties$fin4;\n      // Find properties by name from the properties array\n      const syringeDiameter = ((_deviceProperties$fin = deviceProperties.find(p => p.name === 'diameter')) === null || _deviceProperties$fin === void 0 ? void 0 : _deviceProperties$fin.default) || 0;\n      const syringeLength = ((_deviceProperties$fin2 = deviceProperties.find(p => p.name === 'length')) === null || _deviceProperties$fin2 === void 0 ? void 0 : _deviceProperties$fin2.default) || 0;\n      const stepsPerRevolution = ((_deviceProperties$fin3 = deviceProperties.find(p => p.name === 'steps per revolution')) === null || _deviceProperties$fin3 === void 0 ? void 0 : _deviceProperties$fin3.default) || 0;\n      const lead = ((_deviceProperties$fin4 = deviceProperties.find(p => p.name === 'lead')) === null || _deviceProperties$fin4 === void 0 ? void 0 : _deviceProperties$fin4.default) || 0;\n      const syringeArea = Math.PI * Math.pow(syringeDiameter / 2, 2);\n      const linearSpeed = Math.abs(event.value) / syringeArea;\n      const stepsPerMm = stepsPerRevolution / lead;\n      const stepsPerSecond = linearSpeed * stepsPerMm;\n      const delayMicroseconds = stepsPerSecond > 0 ? Math.round(1000000 / stepsPerSecond) : 0;\n      return {\n        target: event.target,\n        time: Math.round(event.time * 1000000),\n        delay: delayMicroseconds\n      };\n    };\n    const convertThermostatEvent = (event, deviceProperties) => {\n      // Placeholder for thermostat conversion logic\n      return {\n        target: event.target,\n        time: Math.round(event.time * 1000000),\n        temperature: event.value\n        // Add other thermostat-specific parameters here\n      };\n    };\n    const convertLedEvent = (event, deviceProperties) => {\n      // Placeholder for LED conversion logic\n      return {\n        target: event.target,\n        time: Math.round(event.time * 1000000),\n        intensity: event.value\n        // Add other LED-specific parameters here\n      };\n    };\n    const convertDetectorEvent = (event, deviceProperties) => {\n      // Placeholder for detector conversion logic\n      return {\n        target: event.target,\n        time: Math.round(event.time * 1000000),\n        setting: event.value\n        // Add other detector-specific parameters here\n      };\n    };\n    eventList.forEach(deviceEventList => {\n      if (!deviceEventList.length) return;\n      const targetId = deviceEventList[0].target;\n      const deviceNode = nodes.find(node => node.id === targetId);\n      if (!deviceNode || !deviceNode.data) {\n        console.error(`Device node or data not found for ID: ${targetId}`);\n        return;\n      }\n      const deviceEvents = deviceEventList.map(event => {\n        switch (event.type) {\n          case 'setPumpSpeed':\n            return convertPumpEvent(event, deviceNode.data.properties);\n          case 'setThermostatTemperature':\n            return convertThermostatEvent(event, deviceNode.data.properties);\n          case 'setLedIntensity':\n            return convertLedEvent(event, deviceNode.data.properties);\n          case 'setDetectorSetting':\n            return convertDetectorEvent(event, deviceNode.data.properties);\n          default:\n            console.warn(`Unknown event type: ${event.type}`);\n            return null;\n        }\n      }).filter(Boolean); // Remove any null events\n\n      if (deviceEvents.length > 0) {\n        deviceEventMap.set(targetId, deviceEvents);\n      }\n    });\n    console.log('deviceEventMap: ', Array.from(deviceEventMap.values()));\n    return Array.from(deviceEventMap.values());\n  };\n  const generateEventList = blocks => {\n    // Early exit if blocks array is invalid\n    if (!blocks || !Array.isArray(blocks) || blocks.length === 0) {\n      console.warn('No valid blocks found for event generation');\n      return [];\n    }\n    const orderedNodes = orderNodesByDistance(findOutletNode(graphData.nodes), graphData.nodes, graphData.links);\n    console.log('orderedNodes: ', orderedNodes);\n\n    // Early exit if no ordered nodes\n    if (!orderedNodes || orderedNodes.length === 0) {\n      console.warn('No ordered nodes found for event generation');\n      return [];\n    }\n    let eventList = [];\n    let dropletSnapshot = [];\n\n    // Validate block droplets\n    if (!blocks[0] || !blocks[0].droplets || !Array.isArray(blocks[0].droplets) || blocks[0].droplets.length === 0) {\n      console.warn('No valid droplets found in blocks for event generation');\n      return [];\n    }\n    const i = 0;\n    const currentBlockDroplets = blocks[i].droplets;\n\n    // Add fallback for volumetricSpeed in case it's not found\n    const dropletWithParams = currentBlockDroplets.find(d => d && d.parameters && Array.isArray(d.parameters));\n    if (!dropletWithParams) {\n      console.warn('No droplet with valid parameters found');\n      return [];\n    }\n\n    // Make sure we can find the volumetricSpeed parameter or use a default\n    const volumetricSpeedParam = dropletWithParams.parameters.find(p => p && p.name === 'volumetricSpeed');\n    const commonVolumetricSpeed = (volumetricSpeedParam === null || volumetricSpeedParam === void 0 ? void 0 : volumetricSpeedParam.value) || 1;\n    console.log('Using volumetricSpeed:', commonVolumetricSpeed);\n\n    //adds some parameters to nodes\n    orderedNodes.forEach(node => {\n      node.inletVolumetricSpeed = commonVolumetricSpeed;\n      node.outletVolumetricSpeed = commonVolumetricSpeed;\n      const pump = findConnectedPump(node.node.id, graphData.nodes, graphData.links);\n      if (pump) {\n        node.connectedPump = pump;\n      } else {\n        node.connectedPump = 0;\n      }\n      node.connectedPumpRatio = 0;\n      node.connectedPumpSpeedAtPause = 0;\n      node.pumpSpeedMultiplier = 1;\n      //node.requestedRatio = 0;\n      node.pauseLevel = 0;\n    });\n    //ustawia carrier pump na odpowiednią predkość\n    const carrierPumpConnector = graphData.links.find(link => link.source === selectedCarrierPumps[0]).target;\n    if (carrierPumpConnector) {\n      const connectorNode = orderedNodes.find(node => node.node.id === carrierPumpConnector);\n      connectorNode.inletVolumetricSpeed = commonVolumetricSpeed;\n      connectorNode.outletVolumetricSpeed = commonVolumetricSpeed;\n      connectorNode.connectedPump = graphData.nodes.find(node => node.id === selectedCarrierPumps[0]);\n      connectorNode.connectedPumpRatio = 1;\n      connectorNode.connectedPumpSpeedAtPause = commonVolumetricSpeed;\n      //connectorNode.requestedRatio = 0;\n      connectorNode.pauseLevel = 0;\n    }\n    let event = {\n      //it is ok\n      type: 'setPumpSpeed',\n      target: selectedCarrierPumps[0],\n      time: 0,\n      value: commonVolumetricSpeed\n    };\n    eventList.push(event);\n    orderedNodes.filter(node => node.node.type === 'pump' && node.node.id !== selectedCarrierPumps[0]).forEach(pump => {\n      event = {\n        //it is ok\n        type: 'setPumpSpeed',\n        target: pump.node.id,\n        time: 0,\n        value: 0\n      };\n      eventList.push(event);\n    });\n    orderedNodes.filter(node => node.node.type !== 'pump').forEach(pump => {});\n    let position = -0.001;\n    //prepares all droplets in block and calculates some parameters\n    currentBlockDroplets.forEach(droplet => {\n      var _droplet$parameters$f6, _droplet$parameters$f7;\n      const prefixVolume = (_droplet$parameters$f6 = droplet.parameters.find(p => p.name === 'prefixVolume')) === null || _droplet$parameters$f6 === void 0 ? void 0 : _droplet$parameters$f6.value;\n      const surfixVolume = (_droplet$parameters$f7 = droplet.parameters.find(p => p.name === 'surfixVolume')) === null || _droplet$parameters$f7 === void 0 ? void 0 : _droplet$parameters$f7.value;\n      droplet.frontVolumetricSpeed = commonVolumetricSpeed;\n      droplet.rearVolumetricSpeed = commonVolumetricSpeed;\n      droplet.frontVolumetricPosition = position - prefixVolume;\n      droplet.rearVolumetricPosition = droplet.frontVolumetricPosition;\n      droplet.frontVolumetricDistanceToNextNode = Math.abs(droplet.frontVolumetricPosition);\n      droplet.rearVolumetricDistanceToNextNode = Math.abs(droplet.rearVolumetricPosition);\n      droplet.frontTimeToReachNextNode = 0;\n      droplet.rearTimeToReachNextNode = 0;\n      droplet.frontNextNodeID = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id;\n      droplet.rearNextNodeID = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id;\n      droplet.pumpSpeedMultiplier = 1;\n      droplet.pauseLevel = 0;\n      droplet.frontVolumetricSpeedAtPause = 0;\n      droplet.rearVolumetricSpeedAtPause = 0;\n      droplet.stoppingDroplet = false;\n      droplet.initialPumping = false;\n      position -= prefixVolume + surfixVolume;\n    });\n    console.log('findFurthestNode: ', findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id);\n    console.log('Droplet positions initialized, nodes ready');\n    let lastDropletRearPosition = currentBlockDroplets[currentBlockDroplets.length - 1].rearVolumetricPosition;\n    let outletNodePosition = orderedNodes[0].node.volumetricPosition;\n    let timePassed = 0; //in s\n    let newTimePassed = 0;\n\n    // Simulate the movement of droplets in the current block\n    currentBlockDroplets.forEach(droplet => {\n      droplet.frontTimeToReachNextNode = Math.abs(droplet.frontVolumetricDistanceToNextNode / droplet.frontVolumetricSpeed);\n      droplet.rearTimeToReachNextNode = Math.abs(droplet.rearVolumetricDistanceToNextNode / droplet.rearVolumetricSpeed);\n    });\n    while (lastDropletRearPosition < outletNodePosition) {\n      let smallestFrontTime = Infinity;\n      let smallestRearTime = Infinity;\n      let smallestFrontTimeDroplet = [];\n      let smallestRearTimeDroplet = [];\n      currentBlockDroplets.forEach(droplet => {\n        // Update the smallest front and rear times and associated droplet(s) based on the current droplet's front and rear times to reach the next node.\n\n        if (Math.abs(droplet.frontTimeToReachNextNode) < smallestFrontTime) {\n          smallestFrontTime = Math.abs(droplet.frontTimeToReachNextNode);\n          smallestFrontTimeDroplet = [droplet];\n        } else if (Math.abs(droplet.frontTimeToReachNextNode) === smallestFrontTime) {\n          smallestFrontTimeDroplet.push(droplet);\n        }\n        if (Math.abs(droplet.rearTimeToReachNextNode) < smallestRearTime) {\n          smallestRearTime = Math.abs(droplet.rearTimeToReachNextNode);\n          smallestRearTimeDroplet = [droplet];\n        } else if (Math.abs(droplet.rearTimeToReachNextNode) === smallestRearTime) {\n          smallestRearTimeDroplet.push(droplet);\n        }\n      });\n      newTimePassed += Math.min(Math.abs(smallestFrontTime), Math.abs(smallestRearTime));\n      if (smallestFrontTime === smallestRearTime) {\n        //przypadek w ktorym wiele kropel ma ten sam czas do przejścia do nastepnego noda, rzadki\n\n        if (smallestFrontTimeDroplet.length > 1 || smallestRearTimeDroplet.length > 1) {\n          //sprawdź czy wśród nich jest kropla z rear i front\n          console.log('Multiple droplets have reached the next node simultaneously');\n          console.log('smallestFrontTimeDroplet: ', smallestFrontTimeDroplet);\n          console.log('smallestRearTimeDroplet: ', smallestRearTimeDroplet);\n        } else if (smallestFrontTimeDroplet[0] === smallestRearTimeDroplet[0]) {\n          //przypadek gdy kropla ma 0 objętości\n          console.log('Both front and rear times are for the same droplet');\n          const reachedNode = orderedNodes.find(n => n.node.id === smallestFrontTimeDroplet[0].frontNextNodeID);\n          const reachedNodeDistance = orderedNodes.find(node => node.node.id === reachedNode.node.id).distance;\n          if (reachedNode.node.type === 'connector') {\n            const index = currentBlockDroplets.indexOf(smallestFrontTimeDroplet[0]);\n            const dropletsOlder = currentBlockDroplets.slice(0, index);\n            const dropletsNewer = currentBlockDroplets.slice(index + 1);\n            const ds = [];\n            ds.drops = JSON.parse(JSON.stringify(dropletsNewer)); // Create deep copy\n            ds.snappedNode = smallestFrontTimeDroplet[0].frontNextNodeID;\n            const existingSnapshotIndex = dropletSnapshot.findIndex(snapshot => snapshot.snappedNode === ds.snappedNode);\n            if (existingSnapshotIndex !== -1) {\n              dropletSnapshot[existingSnapshotIndex] = ds;\n            } else {\n              dropletSnapshot.push(ds);\n            }\n\n            //aktualizuje starsze krople\n            dropletsOlder.forEach(droplet => {\n              droplet.frontTimeToReachNextNode -= smallestFrontTime;\n              droplet.rearTimeToReachNextNode -= smallestFrontTime;\n              droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\n              droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\n              droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\n              droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\n            });\n\n            //aktualizuje kroplę\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\n            const nextEdge = graphData.links.find(link => link.source === smallestFrontTimeDroplet[0].frontNextNodeID && link.target === nextNode.node.id);\n            if (reachedNode.connectedPump !== null) {\n              var _smallestFrontTimeDro, _smallestFrontTimeDro2;\n              const pumpRatio = ((_smallestFrontTimeDro = smallestFrontTimeDroplet[0].parameters.find(param => param.nodeId === reachedNode.connectedPump.id && param.name === 'ratio')) === null || _smallestFrontTimeDro === void 0 ? void 0 : _smallestFrontTimeDro.value) || 0;\n              const dropletDesiredVolume = ((_smallestFrontTimeDro2 = smallestFrontTimeDroplet[0].parameters.find(param => param.name === 'volume')) === null || _smallestFrontTimeDro2 === void 0 ? void 0 : _smallestFrontTimeDro2.value) || 0;\n              reachedNode.connectedPumpRatio = pumpRatio;\n              //reachedNode.inletVolumetricSpeed = 0;\n              //smallestFrontTimeDroplet[0].frontVolumetricSpeed = reachedNode.outletVolumetricSpeed;\n              smallestFrontTimeDroplet[0].frontVolumetricSpeedAtPause = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n              smallestFrontTimeDroplet[0].rearVolumetricSpeedAtPause = smallestFrontTimeDroplet[0].rearVolumetricSpeed;\n              smallestFrontTimeDroplet[0].rearVolumetricSpeed = 0;\n              smallestFrontTimeDroplet[0].frontVolumetricPosition = reachedNode.node.volumetricPosition;\n              smallestFrontTimeDroplet[0].rearVolumetricPosition = reachedNode.node.volumetricPosition;\n              smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n              smallestFrontTimeDroplet[0].rearVolumetricDistanceToNextNode = 0;\n              smallestFrontTimeDroplet[0].frontTimeToReachNextNode = smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode / smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n              smallestFrontTimeDroplet[0].rearTimeToReachNextNode = dropletDesiredVolume * pumpRatio / smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n              smallestFrontTimeDroplet[0].frontNextNodeID = nextNode.node.id;\n              //smallestFrontTimeDroplet[0].rearNextNodeID = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id;\n              smallestFrontTimeDroplet[0].pumpSpeedMultiplier = 1;\n              //smallestFrontTimeDroplet[0].pauseLevel = 0;\n              smallestFrontTimeDroplet[0].stoppingDroplet = true;\n              smallestFrontTimeDroplet[0].initialPumping = true;\n              if (reachedNode.connectedPump.id !== selectedCarrierPumps[0]) {\n                event = {\n                  type: 'setPumpSpeed',\n                  target: reachedNode.connectedPump.id,\n                  time: newTimePassed,\n                  value: smallestFrontTimeDroplet[0].frontVolumetricSpeed\n                };\n                eventList.push(event);\n              }\n\n              //update newer droplets\n              dropletsNewer.forEach(droplet => {\n                droplet.pauseLevel += 1;\n                if (droplet.pauseLevel === 1) {\n                  droplet.frontVolumetricSpeedAtPause = droplet.frontVolumetricSpeed;\n                  if (droplet.stoppingDroplet !== true) {\n                    droplet.rearVolumetricSpeedAtPause = droplet.rearVolumetricSpeed;\n                  }\n                }\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\n                droplet.frontVolumetricSpeed = 0;\n                droplet.rearVolumetricSpeed = 0;\n                droplet.frontTimeToReachNextNode += smallestFrontTimeDroplet[0].rearTimeToReachNextNode - smallestFrontTime;\n                droplet.rearTimeToReachNextNode += smallestFrontTimeDroplet[0].rearTimeToReachNextNode - smallestFrontTime;\n              });\n              getPumpsBetweenPositions(smallestFrontTimeDroplet[0].frontVolumetricPosition, -1, graphData.nodes, graphData.links).filter(pump => pump.id !== reachedNode.connectedPump.id).forEach(pump => {\n                event = {\n                  type: 'setPumpSpeed',\n                  target: pump.id,\n                  time: newTimePassed,\n                  value: 0\n                };\n                eventList.push(event);\n              });\n            }\n          } else if (reachedNode.type === 'thermostat' || reachedNode.type === 'LED') {\n            console.log('reachedNode is thermostat');\n          } else if (reachedNode.type === 'outlet') {\n            console.log('reachedNode is outlet');\n          } else if (reachedNode.type === 'detector' || reachedNode.type === 'USBSpectrometer' || reachedNode.type === 'MQTTSpectrometer') {\n            console.log('reachedNode is detector');\n          }\n        } else {\n          console.log('Front and rear times are for different droplets');\n        }\n      } else if (smallestFrontTime < smallestRearTime) {\n        //przypadek gdzie przód jest przed tyłem\n        console.log('Front time is smaller than rear time');\n        if (smallestFrontTimeDroplet.length > 1) {\n          console.log(`Multiple droplets have reached the next node simultaneously`);\n          smallestFrontTimeDroplet.forEach(droplet => {\n            // Perform some action for each droplet in smallestFrontTimeDroplet\n          });\n        } else {\n          //przypadek gdy przód jednej kropelki dochodzi do noda\n          console.log(`Single droplet front has reached the next node`);\n          const reachedNode = orderedNodes.find(n => n.node.id === smallestFrontTimeDroplet[0].frontNextNodeID);\n          const reachedNodeDistance = orderedNodes.find(node => node.node.id === reachedNode.node.id).distance;\n          if (reachedNode.node.type === 'connector') {\n            //przypadek gdy dochodzi do connectora\n            console.log('reachedNode is connector');\n            const index = currentBlockDroplets.indexOf(smallestFrontTimeDroplet[0]);\n            const dropletsOlder = currentBlockDroplets.slice(0, index);\n            const dropletsNewer = currentBlockDroplets.slice(index + 1);\n\n            //aktualizuje kroplę\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\n            const nextEdge = graphData.links.find(link => link.source === reachedNode.node.id && link.target === nextNode.node.id);\n            if (reachedNode.connectedPump.id !== null) {\n              var _smallestFrontTimeDro3, _smallestFrontTimeDro4;\n              const pumpRatio = ((_smallestFrontTimeDro3 = smallestFrontTimeDroplet[0].parameters.find(param => param.nodeId === reachedNode.connectedPump.id && param.name === 'ratio')) === null || _smallestFrontTimeDro3 === void 0 ? void 0 : _smallestFrontTimeDro3.value) || 0;\n              const dropletDesiredVolume = ((_smallestFrontTimeDro4 = smallestFrontTimeDroplet[0].parameters.find(param => param.name === 'volume')) === null || _smallestFrontTimeDro4 === void 0 ? void 0 : _smallestFrontTimeDro4.value) || 0;\n              smallestFrontTimeDroplet[0].frontVolumetricPosition = reachedNode.node.volumetricPosition;\n              smallestFrontTimeDroplet[0].rearVolumetricPosition += smallestFrontTime * smallestFrontTimeDroplet[0].rearVolumetricSpeed;\n              smallestFrontTimeDroplet[0].actualVolume = smallestFrontTimeDroplet[0].frontVolumetricPosition - smallestFrontTimeDroplet[0].rearVolumetricPosition;\n              reachedNode.inletVolumetricSpeed = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n              reachedNode.connectedPumpRatio = pumpRatio;\n              smallestFrontTimeDroplet[0].rearTimeToReachNextNode -= smallestFrontTime;\n              smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n              smallestFrontTimeDroplet[0].rearVolumetricDistanceToNextNode -= smallestFrontTime * smallestFrontTimeDroplet[0].rearVolumetricSpeed;\n              if (smallestFrontTimeDroplet[0].initialPumping === true) {\n                //przypadek gdy kropla jest w pierwszej fazie pompowania (od 0uL)\n                console.log('Kropla jest w pierwszej fazie pompowania');\n                //smallestFrontTimeDroplet[0].initialPumping = false;\n                const rearTimeLeft = smallestFrontTimeDroplet[0].rearTimeToReachNextNode;\n                const totalTimeLeft = rearTimeLeft + smallestFrontTimeDroplet[0].actualVolume / commonVolumetricSpeed;\n                console.log('commonVolumetricSpeed: ', commonVolumetricSpeed);\n                console.log('smallestFrontTimeDroplet[0].actualVolume: ', smallestFrontTimeDroplet[0].actualVolume);\n                console.log('rearTimeLeft: ', rearTimeLeft);\n                console.log('totalTimeLeft: ', totalTimeLeft);\n                const thispumpspeed = pumpRatio * dropletDesiredVolume / totalTimeLeft;\n                console.log('thispumpspeed: ', thispumpspeed);\n                reachedNode.connectedPumpSpeedAtPause = thispumpspeed;\n              } else {\n                console.log('Normalne pompowanie');\n                reachedNode.connectedPumpSpeedAtPause = dropletDesiredVolume * pumpRatio / (smallestFrontTimeDroplet[0].actualVolume / reachedNode.inletVolumetricSpeed);\n              }\n              reachedNode.outletVolumetricSpeed = reachedNode.inletVolumetricSpeed + reachedNode.connectedPumpSpeedAtPause;\n              smallestFrontTimeDroplet[0].frontVolumetricSpeed += reachedNode.connectedPumpSpeedAtPause;\n              //smallestFrontTimeDroplet[0].rearVolumetricSpeed = 0;\n              smallestFrontTimeDroplet[0].frontTimeToReachNextNode = smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode / smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n              smallestFrontTimeDroplet[0].frontNextNodeID = nextNode.node.id;\n              //smallestFrontTimeDroplet[0].rearNextNodeID = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id;\n              //smallestFrontTimeDroplet[0].pumpSpeedMultiplier = 1;\n              //smallestFrontTimeDroplet[0].pauseLevel = 0;\n              //smallestFrontTimeDroplet[0].frontVolumetricSpeedAtPause = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n              //smallestFrontTimeDroplet[0].rearVolumetricSpeedAtPause = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n              //smallestFrontTimeDroplet[0].stoppingDroplet = true;\n              event = {\n                type: 'setPumpSpeed',\n                target: reachedNode.connectedPump.id,\n                time: newTimePassed,\n                value: reachedNode.connectedPumpSpeedAtPause\n              };\n              eventList.push(event);\n              //update newer droplets\n              dropletsNewer.forEach(droplet => {\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\n                droplet.frontTimeToReachNextNode -= smallestFrontTime;\n                droplet.rearTimeToReachNextNode -= smallestFrontTime;\n              });\n              //aktualizuje starsze krople\n              let accumulatedSpeed = reachedNode.connectedPumpSpeedAtPause;\n              dropletsOlder.reverse().forEach(droplet => {\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\n                droplet.rearVolumetricSpeed += accumulatedSpeed;\n                getPumpsBetweenPositions(droplet.frontVolumetricPosition, droplet.rearVolumetricPosition, graphData.nodes, graphData.links).forEach(pump => {\n                  const editedNode = orderedNodes.find(node => node.connectedPump.id === pump.id);\n                  //editedNode.pumpSpeedMultiplier = 1;\n                  const pumpBoost = editedNode.connectedPumpSpeedAtPause * accumulatedSpeed / editedNode.inletVolumetricSpeed;\n                  editedNode.connectedPumpSpeedAtPause += pumpBoost;\n                  editedNode.inletVolumetricSpeed += accumulatedSpeed;\n                  accumulatedSpeed += pumpBoost;\n                  editedNode.outletVolumetricSpeed += accumulatedSpeed;\n                  event = {\n                    type: 'setPumpSpeed',\n                    target: pump.id,\n                    time: newTimePassed,\n                    value: editedNode.connectedPumpSpeedAtPause\n                  };\n                  eventList.push(event);\n                });\n                droplet.frontVolumetricSpeed += accumulatedSpeed;\n                droplet.frontTimeToReachNextNode = droplet.frontVolumetricDistanceToNextNode / droplet.frontVolumetricSpeed;\n                droplet.rearTimeToReachNextNode = droplet.rearVolumetricDistanceToNextNode / droplet.rearVolumetricSpeed;\n              });\n            }\n          } else if (reachedNode.node.type === 'thermostat' || reachedNode.type === 'LED') {\n            //przypadek gdy dochodzi do termostatu\n            console.log('reachedNode (thermostat, LED): ', reachedNode);\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\n            if (nextNode) {\n              const nextEdge = graphData.links.find(link => link.source === smallestFrontTimeDroplet[0].frontNextNodeID && link.target === nextNode.node.id);\n              //aktualizuje krople\n              currentBlockDroplets.forEach(droplet => {\n                droplet.frontTimeToReachNextNode -= smallestFrontTime;\n                droplet.rearTimeToReachNextNode -= smallestFrontTime;\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\n              });\n              smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n              smallestFrontTimeDroplet[0].frontTimeToReachNextNode = smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode / smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n              smallestFrontTimeDroplet[0].frontNextNodeID = nextNode.node.id;\n            }\n          } else if (reachedNode.node.type === 'outlet') {\n            //jeśli ostatni node osiągnięty\n            console.log('reachedNode (outlet): ', reachedNode);\n            //typowe zaktualizowanie czasu do następnego noda dla reszty kropel i zestallowanie frontu\n            currentBlockDroplets.forEach(droplet => {\n              droplet.frontTimeToReachNextNode -= smallestFrontTime;\n              droplet.rearTimeToReachNextNode -= smallestFrontTime;\n              droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\n              droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\n              droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\n              droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\n            });\n            smallestFrontTimeDroplet[0].frontTimeToReachNextNode = Infinity;\n            smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = Infinity;\n            smallestFrontTimeDroplet[0].frontNextNodeID = null;\n          } else if (reachedNode.node.type === 'detector' || reachedNode.node.type === 'USBSpectrometer' || reachedNode.node.type === 'MQTTSpectrometer') {\n            //przypadek gdy dochodzi do detektora\n            console.log('reachedNode (detector): ', reachedNode);\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\n            if (nextNode) {\n              const nextEdge = graphData.links.find(link => link.source === smallestFrontTimeDroplet[0].frontNextNodeID && link.target === nextNode.node.id);\n              //aktualizuje krople\n              currentBlockDroplets.forEach(droplet => {\n                droplet.frontTimeToReachNextNode -= smallestFrontTime;\n                droplet.rearTimeToReachNextNode -= smallestFrontTime;\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\n              });\n              smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n              smallestFrontTimeDroplet[0].frontTimeToReachNextNode = smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode / smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n              smallestFrontTimeDroplet[0].frontNextNodeID = nextNode.node.id;\n            }\n          }\n        }\n      } else {\n        //przypadek gdzie tył jest przed przodem\n        console.log('Rear time is smaller than front time');\n        if (smallestRearTimeDroplet.length > 1) {\n          //przypadek gdy dochodzi do noda wiele kropel\n          console.log(`Multiple droplets ends have reached the next node simultaneously`);\n          smallestRearTimeDroplet.forEach(droplet => {\n            // Perform some action for each droplet in smallestRearTimeDroplet\n          });\n        } else {\n          //przypadek gdy tył jednej kropelki dochodzi do noda\n          const reachedNode = orderedNodes.find(n => n.node.id === smallestRearTimeDroplet[0].rearNextNodeID);\n          const reachedNodeDistance = orderedNodes.find(node => node.node.id === reachedNode.node.id).distance;\n          if (reachedNode.node.type === 'connector') {\n            //przypadek gdy dochodzi do connectora\n            console.log('reachedNode is connector');\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\n            const nextEdge = graphData.links.find(link => link.source === smallestRearTimeDroplet[0].rearNextNodeID && link.target === nextNode.node.id);\n            const index = currentBlockDroplets.indexOf(smallestRearTimeDroplet[0]);\n            const dropletsOlder = currentBlockDroplets.slice(0, index);\n            const dropletsNewer = currentBlockDroplets.slice(index + 1);\n            if (smallestRearTimeDroplet[0].stoppingDroplet === true) {\n              //wznawia jeśli była zatrzymana\n              //aktualizuje starsze krople\n              dropletsOlder.forEach(droplet => {\n                droplet.frontTimeToReachNextNode -= smallestRearTime;\n                droplet.rearTimeToReachNextNode -= smallestRearTime;\n                droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\n                droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\n              });\n\n              //aktualizuje nowsze krople\n              dropletsNewer.forEach(droplet => {\n                if (droplet.pauseLevel === 1) {\n                  //\n                  droplet.pauseLevel = 0;\n                  droplet.frontVolumetricSpeed = droplet.frontVolumetricSpeedAtPause;\n                  droplet.rearVolumetricSpeed = droplet.rearVolumetricSpeedAtPause;\n                  getPumpsBetweenPositions(droplet.frontVolumetricPosition, droplet.rearVolumetricPosition, graphData.nodes, graphData.links).forEach(pump => {\n                    event = {\n                      type: 'setPumpSpeed',\n                      target: pump.id,\n                      time: newTimePassed,\n                      value: orderedNodes.find(node => node.node.id === pump.id).connectedPumpSpeedAtPause\n                    };\n                    eventList.push(event);\n                  });\n                } else {\n                  droplet.pauseLevel -= 1;\n                }\n                droplet.frontTimeToReachNextNode -= smallestRearTime;\n                droplet.rearTimeToReachNextNode -= smallestRearTime;\n              });\n              reachedNode.connectedPumpRatio = 0;\n              //reachedNode.inletVolumetricSpeed = 0;\n              //smallestRearTimeDroplet[0].frontVolumetricSpeed = reachedNode.outletVolumetricSpeed;\n              smallestRearTimeDroplet[0].rearVolumetricSpeed = smallestRearTimeDroplet[0].rearVolumetricSpeedAtPause;\n              smallestRearTimeDroplet[0].frontVolumetricPosition += smallestRearTimeDroplet[0].frontVolumetricSpeed * smallestRearTime;\n              smallestRearTimeDroplet[0].rearVolumetricPosition = reachedNode.node.volumetricPosition;\n              smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode -= smallestRearTimeDroplet[0].frontVolumetricSpeed * smallestRearTime;\n              smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n              smallestRearTimeDroplet[0].frontTimeToReachNextNode = smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].frontVolumetricSpeed;\n              smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].rearVolumetricSpeed;\n              //smallestRearTimeDroplet[0].frontNextNodeID = nextNode.id;\n              smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\n              //smallestRearTimeDroplet[0].pumpSpeedMultiplier = 1;\n              //smallestRearTimeDroplet[0].pauseLevel = 0;\n              smallestRearTimeDroplet[0].frontVolumetricSpeedAtPause = smallestRearTimeDroplet[0].frontVolumetricSpeed;\n              smallestRearTimeDroplet[0].rearVolumetricSpeedAtPause = smallestRearTimeDroplet[0].rearVolumetricSpeed;\n              smallestRearTimeDroplet[0].stoppingDroplet = false;\n              smallestRearTimeDroplet[0].initialPumping = false;\n              reachedNode.connectedPumpRatio = 0;\n              event = {\n                type: 'setPumpSpeed',\n                target: reachedNode.connectedPump.id,\n                time: newTimePassed,\n                value: 0\n              };\n              eventList.push(event);\n              event = {\n                type: 'setPumpSpeed',\n                target: selectedCarrierPumps[0],\n                time: newTimePassed,\n                value: commonVolumetricSpeed\n              };\n              eventList.push(event);\n            } else {\n              console.log('it is not stopper');\n              if (reachedNode.connectedPump.id !== null) {\n                const speedDifference = reachedNode.outletVolumetricSpeed - reachedNode.inletVolumetricSpeed;\n                //reachedNode.inletVolumetricSpeed = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\n                reachedNode.outletVolumetricSpeed = reachedNode.inletVolumetricSpeed;\n                reachedNode.connectedPumpRatio = 0;\n                reachedNode.connectedPumpSpeedAtPause = 0;\n                smallestRearTimeDroplet[0].frontVolumetricPosition += smallestRearTime * smallestRearTimeDroplet[0].frontVolumetricSpeed;\n                smallestRearTimeDroplet[0].rearVolumetricPosition = reachedNode.node.volumetricPosition;\n                smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode -= smallestRearTime * smallestRearTimeDroplet[0].frontVolumetricSpeed;\n                smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n                //smallestRearTimeDroplet[0].frontNextNodeID = nextNode.id;\n                smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\n                //smallestRearTimeDroplet[0].pumpSpeedMultiplier = 1;\n                //smallestRearTimeDroplet[0].pauseLevel = 0; \n                //smallestRearTimeDroplet[0].stoppingDroplet = true;\n                smallestRearTimeDroplet[0].frontVolumetricSpeed = smallestRearTimeDroplet[0].frontVolumetricSpeed - speedDifference;\n                //smallestRearTimeDroplet[0].rearVolumetricSpeed = 0;\n                smallestRearTimeDroplet[0].frontVolumetricSpeedAtPause = smallestRearTimeDroplet[0].frontVolumetricSpeed;\n                //smallestRearTimeDroplet[0].rearVolumetricSpeedAtPause = smallestRearTimeDroplet[0].rearVolumetricSpeed;\n                smallestRearTimeDroplet[0].frontTimeToReachNextNode = smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].frontVolumetricSpeed;\n                smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].rearVolumetricSpeed;\n                event = {\n                  type: 'setPumpSpeed',\n                  target: reachedNode.connectedPump.id,\n                  time: newTimePassed,\n                  value: reachedNode.connectedPumpSpeedAtPause\n                };\n                eventList.push(event);\n                //updte newer droplets\n                dropletsNewer.forEach(droplet => {\n                  droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\n                  droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\n                  droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\n                  droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\n                  droplet.frontTimeToReachNextNode -= smallestRearTime;\n                  droplet.rearTimeToReachNextNode -= smallestRearTime;\n                });\n                //aktualizuje starsze krople\n                let accumulatedSpeedDecrease = speedDifference;\n                dropletsOlder.reverse().forEach(droplet => {\n                  droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\n                  droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\n                  droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\n                  droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\n                  droplet.rearVolumetricSpeed -= accumulatedSpeedDecrease;\n                  getPumpsBetweenPositions(droplet.frontVolumetricPosition, droplet.rearVolumetricPosition, graphData.nodes, graphData.links).forEach(pump => {\n                    const editedNode = orderedNodes.find(node => node.connectedPump.id === pump.id);\n                    const pumpBreak = editedNode.connectedPumpSpeedAtPause * accumulatedSpeedDecrease / editedNode.inletVolumetricSpeed;\n                    editedNode.connectedPumpSpeedAtPause -= pumpBreak;\n                    editedNode.inletVolumetricSpeed -= accumulatedSpeedDecrease;\n                    accumulatedSpeedDecrease += pumpBreak;\n                    editedNode.outletVolumetricSpeed -= accumulatedSpeedDecrease;\n                    event = {\n                      type: 'setPumpSpeed',\n                      target: pump.id,\n                      time: newTimePassed,\n                      value: editedNode.connectedPumpSpeedAtPause\n                    };\n                    eventList.push(event);\n                  });\n                  droplet.frontVolumetricSpeed -= accumulatedSpeedDecrease;\n                  droplet.frontTimeToReachNextNode = droplet.frontVolumetricDistanceToNextNode / droplet.frontVolumetricSpeed;\n                  droplet.rearTimeToReachNextNode = droplet.rearVolumetricDistanceToNextNode / droplet.rearVolumetricSpeed;\n                });\n              }\n            }\n          } else if (reachedNode.node.type === 'thermostat' || reachedNode.node.type === 'LED') {\n            //przypadek gdy dochodzi do termostatu\n            console.log('reachedNode thermostat: ', reachedNode);\n            const isFarthestThermostatOrLED = orderedNodes.filter(node => node.node.type === 'thermostat' || node.node.type === 'LED').every(node => node.distance <= reachedNodeDistance);\n\n            // This line checks if the smallestRearTimeDroplet is the last droplet in the currentBlockDroplets array.\n            if (isFarthestThermostatOrLED && currentBlockDroplets.length === currentBlockDroplets.indexOf(smallestRearTimeDroplet[0]) + 1) {\n              var _smallestRearTimeDrop;\n              console.log('This is the farthest thermostat or LED node. Also, last droplet just passed through it.');\n              const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\n              const waitTime = ((_smallestRearTimeDrop = smallestRearTimeDroplet[0].parameters.find(param => param.nodeId === reachedNode.node.id && param.name === 'time')) === null || _smallestRearTimeDrop === void 0 ? void 0 : _smallestRearTimeDrop.value) || 0;\n              if (nextNode) {\n                const nextEdge = graphData.links.find(link => link.source === smallestRearTimeDroplet[0].rearNextNodeID && link.target === nextNode.node.id);\n                smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n                smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].rearVolumetricSpeed + smallestRearTime;\n                smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\n                //aktualizuje resztę kropli\n                currentBlockDroplets.forEach(droplet => {\n                  droplet.frontTimeToReachNextNode += waitTime - smallestRearTime;\n                  droplet.rearTimeToReachNextNode += waitTime - smallestRearTime;\n                  droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\n                  droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\n                  droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed - waitTime * droplet.frontVolumetricSpeed; //to jest zrobione na razie aby czas się zgadzał\n                  droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed - waitTime * droplet.rearVolumetricSpeed;\n                });\n                let carrierPumpEvent = {\n                  type: 'setPumpSpeed',\n                  target: selectedCarrierPumps[0],\n                  // Assuming 'carrierPumpId' is the ID of the carrier pump\n                  time: newTimePassed,\n                  value: 0\n                };\n                eventList.push(carrierPumpEvent);\n                carrierPumpEvent = {\n                  type: 'setPumpSpeed',\n                  target: selectedCarrierPumps[0],\n                  // Assuming 'carrierPumpId' is the ID of the carrier pump\n                  time: newTimePassed + waitTime,\n                  value: commonVolumetricSpeed\n                };\n                eventList.push(carrierPumpEvent);\n              }\n            } else {\n              //droplet wasnt the last one\n              console.log('smallestRearTimeDroplet is not the last droplet in the currentBlockDroplets array');\n              const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\n              if (nextNode) {\n                const nextEdge = graphData.links.find(link => link.source === smallestRearTimeDroplet[0].rearNextNodeID && link.target === nextNode.node.id);\n                //aktualizuje krople\n                currentBlockDroplets.forEach(droplet => {\n                  droplet.frontTimeToReachNextNode -= smallestRearTime;\n                  droplet.rearTimeToReachNextNode -= smallestRearTime;\n                  droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\n                  droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\n                  droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\n                  droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\n                });\n                smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n                smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].rearVolumetricSpeed;\n                smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\n              }\n            }\n          } else if (reachedNode.node.type === 'outlet') {\n            //jeśli ostatni node osiągnięty\n            //typowe zaktualizowanie czasu do następnego noda dla reszty kropel i zestallowanie reara\n            //aktualizuje resztę kropli\n            currentBlockDroplets.forEach(droplet => {\n              droplet.frontTimeToReachNextNode -= smallestRearTime;\n              droplet.rearTimeToReachNextNode -= smallestRearTime;\n              droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\n              droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\n              droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\n              droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\n            });\n            smallestRearTimeDroplet[0].frontTimeToReachNextNode = Infinity;\n            smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode = Infinity;\n            smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = Infinity;\n            smallestRearTimeDroplet[0].rearNextNodeID = null;\n            smallestRearTimeDroplet[0].rearTimeToReachNextNode = Infinity;\n          } else if (reachedNode.node.type === 'detector' || reachedNode.node.type === 'USBSpectrometer' || reachedNode.node.type === 'MQTTSpectrometer') {\n            //przypadek gdy dochodzi do detektora\n            console.log('reachedNode (detector): ', reachedNode);\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\n            if (nextNode) {\n              const nextEdge = graphData.links.find(link => link.source === smallestRearTimeDroplet[0].rearNextNodeID && link.target === nextNode.node.id);\n              //aktualizuje krople\n              currentBlockDroplets.forEach(droplet => {\n                droplet.frontTimeToReachNextNode -= smallestRearTime;\n                droplet.rearTimeToReachNextNode -= smallestRearTime;\n                droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\n                droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\n                droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\n              });\n              smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\n              smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].rearVolumetricSpeed;\n              smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\n            }\n          }\n        }\n      }\n      timePassed = newTimePassed;\n      // Update last droplet rear position\n      lastDropletRearPosition = currentBlockDroplets[currentBlockDroplets.length - 1].rearVolumetricPosition;\n\n      //add code that preserves droplets positions and speeds for visualization\n      const dropletState = {\n        time: timePassed,\n        droplets: currentBlockDroplets.map(droplet => {\n          var _droplet$parameters$f8;\n          return {\n            id: droplet.id,\n            frontVolumetricPosition: droplet.frontVolumetricPosition,\n            rearVolumetricPosition: droplet.rearVolumetricPosition,\n            frontVolumetricSpeed: droplet.frontVolumetricSpeed,\n            rearVolumetricSpeed: droplet.rearVolumetricSpeed,\n            pumpSpeedMultiplier: droplet.pumpSpeedMultiplier,\n            frontTimeToReachNextNode: droplet.frontTimeToReachNextNode,\n            rearTimeToReachNextNode: droplet.rearTimeToReachNextNode,\n            frontVolumetricDistanceToNextNode: droplet.frontVolumetricDistanceToNextNode,\n            rearVolumetricDistanceToNextNode: droplet.rearVolumetricDistanceToNextNode,\n            volume: ((_droplet$parameters$f8 = droplet.parameters.find(p => p.name === 'volume')) === null || _droplet$parameters$f8 === void 0 ? void 0 : _droplet$parameters$f8.value) || 0,\n            frontNextNodeID: droplet.frontNextNodeID,\n            rearNextNodeID: droplet.rearNextNodeID\n          };\n        })\n      };\n      setDropletHistory(prev => [...prev, dropletState]);\n\n      //if (timePassed > 9999) {//here for testing, preventing infinite loop\n      //  lastDropletRearPosition = 88100;\n      //}\n    }\n    event = {\n      //it is ok\n      type: 'setPumpSpeed',\n      target: selectedCarrierPumps[0],\n      time: timePassed,\n      value: 0\n    };\n    eventList.push(event);\n    eventList = cleanAndSortEventList(eventList);\n    console.log('dropletHistory in event generator: ', dropletHistory);\n    console.log('eventList: ', eventList.sort((a, b) => a.time - b.time));\n    setPumpEvents(extractPumpEvents(eventList));\n    return eventList;\n  };\n  // First useEffect to set initial graphData\n  useEffect(() => {\n    setDropletHistory([]);\n    if (nodes.length > 0 && edges.length > 0) {\n      const graphNodes = nodes.map(node => ({\n        id: node.id,\n        label: node.data.label,\n        type: node.data.type,\n        x: 0,\n        y: 0,\n        volumetricPosition: 0\n      }));\n      const graphLinks = edges.map(edge => {\n        var _edge$data, _edge$data$properties, _edge$data2, _edge$data2$propertie;\n        return {\n          source: edge.source,\n          target: edge.target,\n          length: ((_edge$data = edge.data) === null || _edge$data === void 0 ? void 0 : (_edge$data$properties = _edge$data.properties) === null || _edge$data$properties === void 0 ? void 0 : _edge$data$properties.length) || 100,\n          diameter: ((_edge$data2 = edge.data) === null || _edge$data2 === void 0 ? void 0 : (_edge$data2$propertie = _edge$data2.properties) === null || _edge$data2$propertie === void 0 ? void 0 : _edge$data2$propertie.diameter) || 1\n        };\n      });\n      setGraphData({\n        nodes: graphNodes,\n        links: graphLinks\n      });\n    }\n  }, [nodes, edges]);\n\n  // Second useEffect to calculate nodes positions and set up simulation data\n  useEffect(() => {\n    if (!graphData.nodes.length || !graphData.links.length || !droplets.length) {\n      console.log('Missing required data for simulation setup:', {\n        nodesLength: graphData.nodes.length,\n        linksLength: graphData.links.length,\n        dropletsLength: droplets.length\n      });\n      return;\n    }\n    const graphNodes = [...graphData.nodes];\n\n    // Find outlet node first\n    const outletNode = findOutletNode(graphData.nodes);\n    if (!outletNode) {\n      console.error('No outlet node found. Cannot set up simulation.');\n      return;\n    }\n\n    // Get ordered nodes from outlet\n    const orderedNodes = orderNodesByDistance(outletNode, graphData.nodes, graphData.links);\n\n    // Separate nodes into main line and secondary line\n    const mainLineNodes = orderedNodes.filter(({\n      node\n    }) => setOfMainLineNodes.includes(node.type)).reverse();\n    const secondaryLineNodes = orderedNodes.filter(({\n      node\n    }) => setOfSecondaryLineNodes.includes(node.type)).sort((a, b) => b.distance - a.distance);\n\n    // Position settings\n    const mainLineY = 300;\n    const secondaryLineY = 150;\n    const pumpSpacing = 100; // Increased horizontal spacing between pumps\n    let currentX = 100;\n\n    // Position main line nodes\n    let currentVolumetricPosition = 0;\n    mainLineNodes.forEach(({\n      node\n    }, index) => {\n      const graphNode = graphNodes.find(n => n.id === node.id);\n      if (!graphNode) return;\n      graphNode.x = currentX;\n      graphNode.y = mainLineY;\n      graphNode.volumetricPosition = currentVolumetricPosition;\n      if (index < mainLineNodes.length - 1) {\n        const nextNode = mainLineNodes[index + 1];\n        const edge = graphData.links.find(e => e.source === graphNode.id && e.target === nextNode.node.id || e.target === graphNode.id && e.source === nextNode.node.id);\n        if (edge && edge.length) {\n          currentX += edge.length * 2;\n          // Use existing calculateEdgeVolume function\n          const edgeVolume = calculateEdgeVolume(edge);\n          currentVolumetricPosition += edgeVolume;\n        } else {\n          currentX += 200;\n          currentVolumetricPosition += 150;\n        }\n      }\n    });\n\n    // Group secondary nodes by distance\n    const nodesByDistance = {};\n    secondaryLineNodes.forEach(({\n      node,\n      distance\n    }) => {\n      if (!nodesByDistance[distance]) {\n        nodesByDistance[distance] = [];\n      }\n      nodesByDistance[distance].push(node);\n    });\n\n    // Position secondary nodes based on their connected main line nodes\n    const pumpOffset = 50; // Add this constant for pump spacing\n    Object.entries(nodesByDistance).forEach(([distance, nodes]) => {\n      nodes.forEach((node, index) => {\n        const graphNode = graphNodes.find(n => n.id === node.id);\n        if (!graphNode) return;\n\n        // Find connected main line node through edges\n        const connectedEdge = edges.find(e => e.source === node.id || e.target === node.id);\n        if (connectedEdge) {\n          const connectedNodeId = connectedEdge.source === node.id ? connectedEdge.target : connectedEdge.source;\n          const connectedMainNode = graphNodes.find(n => n.id === connectedNodeId);\n          if (connectedMainNode) {\n            // Position pump above its connected main line node with offset if needed\n            graphNode.x = connectedMainNode.x + index * pumpOffset - (nodes.length - 1) * pumpOffset / 2;\n            graphNode.y = secondaryLineY;\n          }\n        }\n      });\n    });\n    setGraphData(prev => ({\n      ...prev,\n      nodes: graphNodes\n    }));\n\n    // Only calculate volumes and blocks if not already done\n    if (currentBlockDroplets.length === 0) {\n      console.log('Calculating thermostat volumes and blocks for droplets:', droplets.length);\n      const thermoVol = calculateVolumesBetweenThermostats(graphData);\n\n      // Create deep copy of droplets to avoid mutation issues\n      const dropletsCopy = JSON.parse(JSON.stringify(droplets));\n      const blocks = divideDropletsIntoBlocks(dropletsCopy, thermoVol);\n      if (blocks.length > 0) {\n        setCurrentBlockDroplets(blocks[0].droplets);\n        // Generate event list only once when initializing\n        const eventList = generateEventList(blocks);\n        const eventListForDevices = recalculateEventListForDevices(eventList);\n      }\n    }\n\n    // Important: the dependency array includes currentBlockDroplets.length to prevent infinite recalculations\n  }, [graphData.nodes.length, graphData.links.length, droplets, edges, currentBlockDroplets.length]);\n  const startSimulation = useCallback(() => {\n    setIsSimulationRunning(true);\n    lastFrameTimeRef.current = null; // Reset the last frame time\n  }, []);\n  const stopSimulation = useCallback(() => {\n    setIsSimulationRunning(false);\n    if (animationFrameRef.current) {\n      cancelAnimationFrame(animationFrameRef.current);\n      animationFrameRef.current = null;\n    }\n  }, []);\n  const restartSimulation = useCallback(() => {\n    stopSimulation();\n    setKey(prevKey => prevKey + 1);\n    setCurrentTime(0);\n    startSimulation();\n  }, [stopSimulation, startSimulation]);\n  const getNodeColor = node => {\n    switch (node.type) {\n      case 'pump':\n        return '#4CAF50';\n      case 'connector':\n        return '#2196F3';\n      case 'outlet':\n        return '#F44336';\n      default:\n        return '#FFA000';\n      // Default color for unknown types\n    }\n  };\n\n  // Update volumetricToXPosition function\n  const volumetricToXPosition = useCallback(volumetricPosition => {\n    var _graphData$nodes$find, _graphData$nodes$find2;\n    const outletNode = findOutletNode(graphData.nodes);\n    const furthestNode = findFurthestNode(outletNode, graphData.nodes, graphData.links);\n    if (!outletNode || !furthestNode) return 0;\n    const totalVolume = getVolumeBetweenNodes(furthestNode.id, outletNode.id, graphData.nodes, graphData.links);\n    const outletX = ((_graphData$nodes$find = graphData.nodes.find(n => n.id === outletNode.id)) === null || _graphData$nodes$find === void 0 ? void 0 : _graphData$nodes$find.x) || 0;\n    const furthestX = ((_graphData$nodes$find2 = graphData.nodes.find(n => n.id === furthestNode.id)) === null || _graphData$nodes$find2 === void 0 ? void 0 : _graphData$nodes$find2.x) || 0;\n\n    // Handle edge cases\n    if (!totalVolume || totalVolume === 0 || isNaN(totalVolume)) {\n      console.warn('Total volume is invalid:', totalVolume);\n      return furthestX;\n    }\n    if (volumetricPosition === undefined || volumetricPosition === null || isNaN(volumetricPosition)) {\n      console.warn('Volumetric position is invalid:', volumetricPosition);\n      return furthestX;\n    }\n\n    // Clamp the position to valid range\n    const clampedPosition = Math.max(-totalVolume, Math.min(totalVolume, volumetricPosition));\n\n    // Apply scaling factor to the position calculation\n    const scaledX = furthestX + clampedPosition / totalVolume * (outletX - furthestX);\n\n    // Ensure the returned value is a valid number\n    if (!isFinite(scaledX) || isNaN(scaledX)) {\n      console.warn('Invalid scaled position calculated:', {\n        scaledX,\n        clampedPosition,\n        totalVolume,\n        outletX,\n        furthestX\n      });\n      return furthestX;\n    }\n    return scaledX;\n  }, [graphData.nodes]);\n\n  // Update the updateDropletPositions function\n  const updateDropletPositions = useCallback(timestamp => {\n    if (!isSimulationRunning || dropletHistory.length === 0) return;\n    if (!lastFrameTimeRef.current) {\n      lastFrameTimeRef.current = timestamp;\n      animationFrameRef.current = requestAnimationFrame(updateDropletPositions);\n      return;\n    }\n    const deltaTime = (timestamp - lastFrameTimeRef.current) / 1000; // Convert to seconds\n    const simulationDeltaTime = deltaTime * timeScale;\n    setCurrentTime(prevTime => {\n      const newTime = prevTime + simulationDeltaTime;\n\n      // Get the time range of our history\n      const lastHistoryTime = dropletHistory[dropletHistory.length - 1].time;\n\n      // If we've reached the end, loop back to start\n      if (newTime >= lastHistoryTime) {\n        setCurrentTime(0);\n        return 0;\n      }\n\n      // Find the appropriate states to interpolate between\n      const currentState = interpolateDropletState(newTime);\n      // Update droplet visualization\n      const updatedDroplets = currentState.map(droplet => {\n        const frontX = volumetricToXPosition(droplet.frontVolumetricPosition);\n        const rearX = volumetricToXPosition(droplet.rearVolumetricPosition);\n        if (isNaN(frontX) || isNaN(rearX)) {\n          console.warn('Invalid droplet position calculated:', {\n            dropletId: droplet.id,\n            frontPosition: droplet.frontVolumetricPosition,\n            rearPosition: droplet.rearVolumetricPosition,\n            frontX,\n            rearX\n          });\n          return null;\n        }\n        return {\n          id: droplet.id,\n          frontX,\n          rearX,\n          y: 300,\n          volume: droplet.frontVolumetricPosition - droplet.rearVolumetricPosition,\n          speed: droplet.frontVolumetricSpeed\n        };\n      }).filter(Boolean);\n      setSimulationDroplets(updatedDroplets);\n      return newTime;\n    });\n    lastFrameTimeRef.current = timestamp;\n    animationFrameRef.current = requestAnimationFrame(updateDropletPositions);\n  }, [isSimulationRunning, timeScale, volumetricToXPosition, dropletHistory]);\n\n  // Add animation effect\n  useEffect(() => {\n    if (isSimulationRunning) {\n      lastFrameTimeRef.current = null;\n      animationFrameRef.current = requestAnimationFrame(updateDropletPositions);\n    }\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [isSimulationRunning, updateDropletPositions]);\n\n  // Add this helper function for interpolation\n  const interpolateDropletState = time => {\n    if (!dropletHistory.length) return [];\n\n    // Find the two closest states\n    const index = dropletHistory.findIndex(state => state.time > time);\n    if (index === -1) return dropletHistory[dropletHistory.length - 1].droplets;\n    if (index === 0) return dropletHistory[0].droplets;\n    const beforeState = dropletHistory[index - 1];\n    const afterState = dropletHistory[index];\n    const fraction = (time - beforeState.time) / (afterState.time - beforeState.time);\n    return beforeState.droplets.map(beforeDroplet => {\n      const afterDroplet = afterState.droplets.find(d => d.id === beforeDroplet.id);\n      if (!afterDroplet) return beforeDroplet;\n      return {\n        ...beforeDroplet,\n        frontVolumetricPosition: beforeDroplet.frontVolumetricPosition + (afterDroplet.frontVolumetricPosition - beforeDroplet.frontVolumetricPosition) * fraction,\n        rearVolumetricPosition: beforeDroplet.rearVolumetricPosition + (afterDroplet.rearVolumetricPosition - beforeDroplet.rearVolumetricPosition) * fraction\n      };\n    });\n  };\n\n  // Add navigation functions\n  const jumpToTimepoint = useCallback(index => {\n    if (index >= 0 && index < dropletHistory.length) {\n      setCurrentTimepoint(index);\n      setCurrentTime(dropletHistory[index].time);\n    }\n  }, [dropletHistory]);\n  const nextTimepoint = useCallback(() => {\n    jumpToTimepoint(currentTimepoint + 1);\n  }, [currentTimepoint, jumpToTimepoint]);\n  const previousTimepoint = useCallback(() => {\n    jumpToTimepoint(currentTimepoint - 1);\n  }, [currentTimepoint, jumpToTimepoint]);\n  const handleNodeClick = node => {\n    var _node$data2, _node$data3;\n    console.log('Node clicked:', node);\n    console.log('Node type:', node.type);\n    console.log('Node data type:', (_node$data2 = node.data) === null || _node$data2 === void 0 ? void 0 : _node$data2.type);\n\n    // Check both node.type and node.data.type\n    const nodeType = node.type || ((_node$data3 = node.data) === null || _node$data3 === void 0 ? void 0 : _node$data3.type);\n    console.log('Determined node type:', nodeType);\n    if (nodeType === 'pump' || nodeType === 'USBSpectrometer' || nodeType === 'MQTTSpectrometer') {\n      setSelectedNode(node);\n      console.log('Selected node set:', node.id, nodeType);\n    }\n  };\n  const handleNodeAction = action => {\n    console.log('Node action:', action);\n    // Here you would implement the actual device communication\n    // based on the action type and parameters\n  };\n  const togglePumpSpeeds = () => {\n    setDisplayPumpSpeeds(!displayPumpSpeeds);\n  };\n\n  // Toggle functions for each display option\n  const toggleNodeIds = () => {\n    setDisplayNodeIds(!displayNodeIds);\n  };\n  const toggleDropletInfo = () => {\n    setDisplayDropletInfo(!displayDropletInfo);\n  };\n  const toggleDropletGaps = () => {\n    setDisplayDropletGaps(!displayDropletGaps);\n  };\n  const toggleEdgeLabels = () => {\n    setDisplayEdgeLabels(!displayEdgeLabels);\n  };\n  const toggleDisplayMenu = () => {\n    setDisplayMenuOpen(!isDisplayMenuOpen);\n  };\n  const toggleTimelineDropletInfo = () => {\n    setDisplayTimelineDropletInfo(!displayTimelineDropletInfo);\n  };\n\n  // Close menu when clicking outside\n  useEffect(() => {\n    const handleClickOutside = event => {\n      if (displayMenuRef.current && !displayMenuRef.current.contains(event.target)) {\n        setDisplayMenuOpen(false);\n      }\n    };\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => {\n      document.removeEventListener('mousedown', handleClickOutside);\n    };\n  }, []);\n\n  // Function to toggle pump panel visibility\n  const togglePumpPanel = pumpId => {\n    setVisiblePumpPanel(prev => prev === pumpId ? null : pumpId);\n  };\n\n  // Add styles for the display menu\n  const styles = {\n    container: {\n      ...backgroundVariants.mainBackground,\n      padding: '20px',\n      minHeight: '100vh'\n    },\n    dropletInfo: {\n      padding: '8px',\n      borderRadius: '4px',\n      fontSize: '12px',\n      ...backgroundVariants.panelBackground,\n      color: '#fff',\n      minWidth: '150px'\n    },\n    timelineContainer: {\n      display: 'flex',\n      flexDirection: 'column',\n      gap: '10px',\n      marginBottom: '20px'\n    },\n    timeInput: {\n      width: '100px',\n      ...backgroundVariants.inputBackground,\n      padding: '5px',\n      borderRadius: '4px',\n      marginLeft: '8px'\n    },\n    buttonGroup: {\n      display: 'flex',\n      gap: '10px',\n      marginTop: '20px',\n      marginBottom: '20px'\n    },\n    timelineControls: {\n      display: 'flex',\n      flexDirection: 'column',\n      gap: '15px',\n      marginBottom: '20px',\n      ...backgroundVariants.panelBackground,\n      padding: '15px',\n      borderRadius: '4px'\n    },\n    timeControls: {\n      display: 'flex',\n      flexDirection: 'column',\n      gap: '15px'\n    },\n    sliderContainer: {\n      display: 'flex',\n      gap: '10px',\n      alignItems: 'center',\n      borderBottom: '1px solid rgba(255,255,255,0.1)',\n      paddingBottom: '15px'\n    },\n    timeStepButtons: {\n      display: 'flex',\n      gap: '5px',\n      alignItems: 'center',\n      justifyContent: 'flex-start'\n    },\n    timeScaleContainer: {\n      display: 'flex',\n      alignItems: 'center',\n      gap: '15px',\n      justifyContent: 'flex-start',\n      borderTop: '1px solid rgba(255,255,255,0.1)',\n      paddingTop: '15px'\n    },\n    svgContainer: {\n      background: backgroundVariants.panelBackground.background,\n      borderRadius: '4px',\n      padding: '10px'\n    },\n    navigationButtons: {\n      display: 'flex',\n      justifyContent: 'space-between',\n      marginBottom: '20px'\n    },\n    timeSlider: {\n      width: '33%',\n      ...backgroundVariants.inputBackground,\n      height: '20px',\n      borderRadius: '10px',\n      WebkitAppearance: 'none',\n      appearance: 'none',\n      background: backgroundVariants.inputBackground.background,\n      outline: 'none',\n      opacity: '0.7',\n      transition: 'opacity .2s',\n      '&:hover': {\n        opacity: '1'\n      },\n      '&::-webkit-slider-thumb': {\n        WebkitAppearance: 'none',\n        appearance: 'none',\n        width: '20px',\n        height: '20px',\n        background: '#4CAF50',\n        cursor: 'pointer',\n        borderRadius: '50%'\n      },\n      '&::-moz-range-thumb': {\n        width: '20px',\n        height: '20px',\n        background: '#4CAF50',\n        cursor: 'pointer',\n        borderRadius: '50%'\n      }\n    },\n    // Add styles for display menu\n    displayMenuButton: {\n      ...buttonVariants.infoButton,\n      position: 'relative'\n    },\n    displayMenu: {\n      position: 'absolute',\n      top: '100%',\n      right: 0,\n      backgroundColor: '#333',\n      border: '1px solid #555',\n      borderRadius: '4px',\n      padding: '8px 0',\n      zIndex: 1000,\n      width: '220px',\n      boxShadow: '0 2px 10px rgba(0, 0, 0, 0.3)'\n    },\n    menuItem: {\n      padding: '8px 16px',\n      cursor: 'pointer',\n      display: 'flex',\n      alignItems: 'center',\n      justifyContent: 'space-between',\n      color: 'white',\n      transition: 'background-color 0.2s',\n      '&:hover': {\n        backgroundColor: '#444'\n      }\n    },\n    checkmark: {\n      color: '#4CAF50',\n      fontWeight: 'bold'\n    }\n  };\n  const sliderStyle = {\n    width: '100%',\n    height: '10px',\n    borderRadius: '5px',\n    background: '#333',\n    outline: 'none',\n    opacity: '0.7',\n    transition: 'opacity .2s'\n    // Remove all pseudo-element styles that were here\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: styles.container,\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      style: styles.timelineControls,\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        style: styles.timeControls,\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          style: styles.sliderContainer,\n          children: [/*#__PURE__*/_jsxDEV(\"input\", {\n            type: \"range\",\n            min: 0,\n            max: Math.max(0, dropletHistory.length - 1),\n            value: currentTimepoint,\n            onChange: e => jumpToTimepoint(Number(e.target.value)),\n            disabled: isSimulationRunning,\n            style: styles.timeSlider,\n            className: \"time-slider\" // Add this className\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1686,\n            columnNumber: 13\n          }, this), displayTimelineDropletInfo && /*#__PURE__*/_jsxDEV(\"div\", {\n            style: {\n              display: 'flex',\n              gap: '10px',\n              flexWrap: 'wrap'\n            },\n            children: dropletHistory.length > 0 && ((_dropletHistory$curre = dropletHistory[currentTimepoint]) === null || _dropletHistory$curre === void 0 ? void 0 : _dropletHistory$curre.droplets.map((droplet, index) => {\n              var _graphData$nodes$find3, _graphData$nodes$find4;\n              return /*#__PURE__*/_jsxDEV(\"div\", {\n                style: styles.dropletInfo,\n                children: [/*#__PURE__*/_jsxDEV(\"div\", {\n                  children: [\"Droplet \", index + 1, \":\"]\n                }, void 0, true, {\n                  fileName: _jsxFileName,\n                  lineNumber: 1700,\n                  columnNumber: 21\n                }, this), droplet.frontNextNodeID && /*#__PURE__*/_jsxDEV(\"div\", {\n                  children: [\"Front \\u2192 \", ((_graphData$nodes$find3 = graphData.nodes.find(n => n.id === droplet.frontNextNodeID)) === null || _graphData$nodes$find3 === void 0 ? void 0 : _graphData$nodes$find3.label) || droplet.frontNextNodeID]\n                }, void 0, true, {\n                  fileName: _jsxFileName,\n                  lineNumber: 1702,\n                  columnNumber: 23\n                }, this), droplet.rearNextNodeID && /*#__PURE__*/_jsxDEV(\"div\", {\n                  children: [\"Rear \\u2192 \", ((_graphData$nodes$find4 = graphData.nodes.find(n => n.id === droplet.rearNextNodeID)) === null || _graphData$nodes$find4 === void 0 ? void 0 : _graphData$nodes$find4.label) || droplet.rearNextNodeID]\n                }, void 0, true, {\n                  fileName: _jsxFileName,\n                  lineNumber: 1705,\n                  columnNumber: 23\n                }, this)]\n              }, droplet.id, true, {\n                fileName: _jsxFileName,\n                lineNumber: 1699,\n                columnNumber: 19\n              }, this);\n            }))\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1697,\n            columnNumber: 15\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1685,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          style: styles.timeStepButtons,\n          children: [/*#__PURE__*/_jsxDEV(\"button\", {\n            onClick: () => jumpToTimepoint(0),\n            disabled: currentTimepoint === 0 || isSimulationRunning,\n            style: {\n              ...buttonVariants.secondaryButton,\n              padding: '4px 8px'\n            },\n            children: \"\\u23EE\\uFE0F Start\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1714,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n            onClick: () => jumpToTimepoint(currentTimepoint - 1),\n            disabled: currentTimepoint === 0 || isSimulationRunning,\n            style: {\n              ...buttonVariants.secondaryButton,\n              padding: '4px 8px'\n            },\n            children: \"\\u23EA Previous\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1721,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n            onClick: () => jumpToTimepoint(currentTimepoint + 1),\n            disabled: currentTimepoint >= dropletHistory.length - 1 || isSimulationRunning,\n            style: {\n              ...buttonVariants.secondaryButton,\n              padding: '4px 8px'\n            },\n            children: \"Next \\u23E9\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1728,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n            onClick: () => jumpToTimepoint(dropletHistory.length - 1),\n            disabled: currentTimepoint >= dropletHistory.length - 1 || isSimulationRunning,\n            style: {\n              ...buttonVariants.secondaryButton,\n              padding: '4px 8px'\n            },\n            children: \"End \\u23ED\\uFE0F\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1735,\n            columnNumber: 13\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1713,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          style: styles.timeScaleContainer,\n          children: [/*#__PURE__*/_jsxDEV(\"label\", {\n            style: {\n              color: '#fff',\n              marginRight: '10px'\n            },\n            children: [\"Time Scale:\", /*#__PURE__*/_jsxDEV(\"select\", {\n              value: timeScale,\n              onChange: e => setTimeScale(Number(e.target.value)),\n              style: styles.timeInput,\n              children: [/*#__PURE__*/_jsxDEV(\"option\", {\n                value: 0.0625,\n                children: \"1/16x\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1752,\n                columnNumber: 17\n              }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n                value: 0.25,\n                children: \"1/4x\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1753,\n                columnNumber: 17\n              }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n                value: 1,\n                children: \"1x\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1754,\n                columnNumber: 17\n              }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n                value: 4,\n                children: \"4x\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1755,\n                columnNumber: 17\n              }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n                value: 16,\n                children: \"16x\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1756,\n                columnNumber: 17\n              }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n                value: 64,\n                children: \"64x\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1757,\n                columnNumber: 17\n              }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n                value: 256,\n                children: \"256x\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1758,\n                columnNumber: 17\n              }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n                value: 1024,\n                children: \"1024x\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1759,\n                columnNumber: 17\n              }, this)]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 1747,\n              columnNumber: 15\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1745,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"label\", {\n            style: {\n              color: '#fff',\n              marginRight: '10px'\n            },\n            children: [\"Current Time: \", currentTime.toFixed(2), \"s\"]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1762,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"label\", {\n            style: {\n              color: '#fff'\n            },\n            children: [\"Step: \", currentTimepoint + 1, \"/\", dropletHistory.length]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1765,\n            columnNumber: 13\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1744,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1684,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1683,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: styles.buttonGroup,\n      children: [/*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: isSimulationRunning ? stopSimulation : startSimulation,\n        style: {\n          ...buttonVariants.primaryButton\n        },\n        children: isSimulationRunning ? 'Stop Simulation' : 'Start Simulation'\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1773,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: restartSimulation,\n        style: {\n          ...buttonVariants.secondaryButton\n        },\n        children: \"Restart simulation\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1779,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: sendingEventsToDevices,\n        style: {\n          ...buttonVariants.primaryButton\n        },\n        children: \"Send Events to Devices\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1785,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        ref: displayMenuRef,\n        style: {\n          position: 'relative',\n          display: 'inline-block'\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: toggleDisplayMenu,\n          style: styles.displayMenuButton,\n          children: \"Display Settings\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1792,\n          columnNumber: 11\n        }, this), isDisplayMenuOpen && /*#__PURE__*/_jsxDEV(\"div\", {\n          style: styles.displayMenu,\n          children: [/*#__PURE__*/_jsxDEV(\"div\", {\n            style: styles.menuItem,\n            onClick: toggleNodeIds,\n            children: [/*#__PURE__*/_jsxDEV(\"span\", {\n              children: \"Show Node IDs\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1804,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n              style: styles.checkmark,\n              children: displayNodeIds ? '✓' : ''\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1805,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1800,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            style: styles.menuItem,\n            onClick: toggleDropletInfo,\n            children: [/*#__PURE__*/_jsxDEV(\"span\", {\n              children: \"Show Droplet Info\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1811,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n              style: styles.checkmark,\n              children: displayDropletInfo ? '✓' : ''\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1812,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1807,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            style: styles.menuItem,\n            onClick: toggleDropletGaps,\n            children: [/*#__PURE__*/_jsxDEV(\"span\", {\n              children: \"Show Droplet Gaps\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1818,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n              style: styles.checkmark,\n              children: displayDropletGaps ? '✓' : ''\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1819,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1814,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            style: styles.menuItem,\n            onClick: toggleEdgeLabels,\n            children: [/*#__PURE__*/_jsxDEV(\"span\", {\n              children: \"Show Tube Dimensions\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1825,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n              style: styles.checkmark,\n              children: displayEdgeLabels ? '✓' : ''\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1826,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1821,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            style: styles.menuItem,\n            onClick: togglePumpSpeeds,\n            children: [/*#__PURE__*/_jsxDEV(\"span\", {\n              children: \"Show Pump Speeds\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1832,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n              style: styles.checkmark,\n              children: displayPumpSpeeds ? '✓' : ''\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1833,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1828,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            style: styles.menuItem,\n            onClick: toggleTimelineDropletInfo,\n            children: [/*#__PURE__*/_jsxDEV(\"span\", {\n              children: \"Show Timeline Droplet Info\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1839,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n              style: styles.checkmark,\n              children: displayTimelineDropletInfo ? '✓' : ''\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1840,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1835,\n            columnNumber: 15\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1799,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1791,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 1772,\n      columnNumber: 7\n    }, this), graphData.nodes.length > 0 && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: styles.svgContainer,\n      children: /*#__PURE__*/_jsxDEV(\"svg\", {\n        width: \"2000\",\n        height: \"400\",\n        children: [graphData.links.map((link, index) => {\n          const sourceNode = graphData.nodes.find(node => node.id === link.source);\n          const targetNode = graphData.nodes.find(node => node.id === link.target);\n          if (!sourceNode || !targetNode) return null;\n          const midX = (sourceNode.x + targetNode.x) / 2;\n          const midY = (sourceNode.y + targetNode.y) / 2;\n          return /*#__PURE__*/_jsxDEV(\"g\", {\n            children: [/*#__PURE__*/_jsxDEV(\"line\", {\n              x1: sourceNode.x,\n              y1: sourceNode.y,\n              x2: targetNode.x,\n              y2: targetNode.y,\n              stroke: \"#999\",\n              strokeWidth: 2\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1862,\n              columnNumber: 19\n            }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n              x: midX,\n              y: midY - 20,\n              textAnchor: \"middle\",\n              fill: \"#fff\",\n              fontSize: \"12px\",\n              style: {\n                display: displayEdgeLabels ? 'block' : 'none'\n              },\n              children: `${link.length} mm (Ø ${link.diameter} mm)`\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1870,\n              columnNumber: 19\n            }, this)]\n          }, `edge-${index}`, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1861,\n            columnNumber: 17\n          }, this);\n        }), graphData.nodes.map((node, index) => /*#__PURE__*/_jsxDEV(\"g\", {\n          children: [/*#__PURE__*/_jsxDEV(\"circle\", {\n            cx: node.x,\n            cy: node.y,\n            r: 15,\n            fill: getNodeColor(node),\n            stroke: selectedNode && selectedNode.id === node.id ? '#FFA500' : 'none',\n            strokeWidth: selectedNode && selectedNode.id === node.id ? '3' : '0',\n            onClick: () => handleNodeClick(node),\n            style: {\n              cursor: 'pointer'\n            }\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1887,\n            columnNumber: 17\n          }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n            x: node.x,\n            y: node.y - 25,\n            textAnchor: \"middle\",\n            fill: \"#fff\",\n            fontSize: \"12px\",\n            children: node.label\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1897,\n            columnNumber: 17\n          }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n            x: node.x,\n            y: node.y - 10,\n            textAnchor: \"middle\",\n            fill: \"#fff\",\n            fontSize: \"10px\",\n            style: {\n              display: displayNodeIds ? 'block' : 'none'\n            },\n            children: `ID: ${node.id}`\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1906,\n            columnNumber: 17\n          }, this)]\n        }, `node-${index}`, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1886,\n          columnNumber: 15\n        }, this)), interpolateDropletState(currentTime).map((droplet, index, droplets) => {\n          const frontX = volumetricToXPosition(droplet.frontVolumetricPosition);\n          const rearX = volumetricToXPosition(droplet.rearVolumetricPosition);\n          const centerX = (frontX + rearX) / 2;\n\n          // Calculate distance to next droplet if this isn't the last droplet\n          const distanceInfo = index < droplets.length - 1 ? {\n            nextDropletFront: droplets[index + 1].frontVolumetricPosition,\n            distance: Math.abs(droplets[index + 1].frontVolumetricPosition - droplet.rearVolumetricPosition)\n          } : null;\n\n          // Calculate midpoint for distance label\n          const distanceLabelX = distanceInfo ? (volumetricToXPosition(droplet.rearVolumetricPosition) + volumetricToXPosition(distanceInfo.nextDropletFront)) / 2 : null;\n          return /*#__PURE__*/_jsxDEV(\"g\", {\n            children: [/*#__PURE__*/_jsxDEV(\"line\", {\n              x1: rearX,\n              y1: 300,\n              x2: frontX,\n              y2: 300,\n              stroke: \"rgba(255, 100, 100, 0.9)\",\n              strokeWidth: 8,\n              strokeLinecap: \"butt\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1939,\n              columnNumber: 19\n            }, this), distanceInfo && displayDropletGaps && /*#__PURE__*/_jsxDEV(\"g\", {\n              children: [/*#__PURE__*/_jsxDEV(\"line\", {\n                x1: rearX,\n                y1: 320,\n                x2: volumetricToXPosition(distanceInfo.nextDropletFront),\n                y2: 320,\n                stroke: \"#fff\",\n                strokeWidth: 1,\n                strokeDasharray: \"5,5\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1953,\n                columnNumber: 23\n              }, this), /*#__PURE__*/_jsxDEV(\"line\", {\n                x1: rearX,\n                y1: 315,\n                x2: rearX,\n                y2: 325,\n                stroke: \"#fff\",\n                strokeWidth: 1\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1963,\n                columnNumber: 23\n              }, this), /*#__PURE__*/_jsxDEV(\"line\", {\n                x1: volumetricToXPosition(distanceInfo.nextDropletFront),\n                y1: 315,\n                x2: volumetricToXPosition(distanceInfo.nextDropletFront),\n                y2: 325,\n                stroke: \"#666\",\n                strokeWidth: 1\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1971,\n                columnNumber: 23\n              }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n                x: distanceLabelX,\n                y: 335,\n                textAnchor: \"middle\",\n                fill: \"#666\",\n                fontSize: \"12px\",\n                children: `${distanceInfo.distance.toFixed(2)} μL`\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1980,\n                columnNumber: 23\n              }, this)]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 1951,\n              columnNumber: 21\n            }, this), displayDropletInfo && /*#__PURE__*/_jsxDEV(_Fragment, {\n              children: [/*#__PURE__*/_jsxDEV(\"text\", {\n                x: centerX,\n                y: 270,\n                textAnchor: \"middle\",\n                fill: \"#6f6\",\n                fontSize: \"12px\",\n                children: `Vol: ${(droplet.frontVolumetricPosition - droplet.rearVolumetricPosition).toFixed(2)} μL`\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1995,\n                columnNumber: 23\n              }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n                x: centerX,\n                y: 255,\n                textAnchor: \"middle\",\n                fill: \"#6f6\",\n                fontSize: \"12px\",\n                children: `Spd f: ${droplet.frontVolumetricSpeed.toFixed(2)} μL/s`\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 2004,\n                columnNumber: 23\n              }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n                x: centerX,\n                y: 240,\n                textAnchor: \"middle\",\n                fill: \"#6f6\",\n                fontSize: \"12px\",\n                children: `Spd r: ${droplet.rearVolumetricSpeed.toFixed(2)} μL/s`\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 2013,\n                columnNumber: 23\n              }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n                x: centerX,\n                y: 225,\n                textAnchor: \"middle\",\n                fill: \"#6f6\",\n                fontSize: \"12px\",\n                children: `mlt: ${droplet.pumpSpeedMultiplier.toFixed(2)}`\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 2022,\n                columnNumber: 23\n              }, this)]\n            }, void 0, true)]\n          }, `droplet-${droplet.id}`, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1937,\n            columnNumber: 17\n          }, this);\n        }), displayPumpSpeeds && graphData.nodes.map((node, index) => {\n          if (node.type === 'pump') {\n            var _dropletHistory;\n            const currentSpeed = getPumpSpeedAtTime(node.id, pumpEvents, currentTime);\n            const maxTime = ((_dropletHistory = dropletHistory[dropletHistory.length - 1]) === null || _dropletHistory === void 0 ? void 0 : _dropletHistory.time) || 1;\n            const pumpSpecificEvents = pumpEvents.filter(event => event.target === node.id);\n            return /*#__PURE__*/_jsxDEV(\"g\", {\n              children: [/*#__PURE__*/_jsxDEV(\"text\", {\n                x: node.x,\n                y: node.y - 35,\n                textAnchor: \"middle\",\n                fill: \"#4CAF50\",\n                fontSize: \"12px\",\n                children: `${currentSpeed.toFixed(2)} μL/s`\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 2046,\n                columnNumber: 21\n              }, this), /*#__PURE__*/_jsxDEV(\"g\", {\n                transform: `translate(${node.x - 40}, ${node.y - 65})`,\n                children: [pumpSpecificEvents.map((event, i, arr) => {\n                  const nextEvent = arr[i + 1];\n                  const width = 80;\n                  const x = 0;\n                  const y = 0;\n\n                  // Calculate position based on time\n                  const timePosition = event.time / maxTime * width;\n                  const nextTimePosition = nextEvent ? nextEvent.time / maxTime * width : width;\n\n                  // Calculate height based on speed value (normalized)\n                  const maxSpeed = Math.max(...pumpSpecificEvents.map(e => e.value));\n                  const normalizedHeight = event.value / (maxSpeed || 1) * 20;\n                  return /*#__PURE__*/_jsxDEV(\"g\", {\n                    children: [/*#__PURE__*/_jsxDEV(\"line\", {\n                      x1: x + timePosition,\n                      y1: y - normalizedHeight,\n                      x2: x + nextTimePosition,\n                      y2: y - normalizedHeight,\n                      stroke: \"#4CAF50\",\n                      strokeWidth: 2\n                    }, void 0, false, {\n                      fileName: _jsxFileName,\n                      lineNumber: 2077,\n                      columnNumber: 29\n                    }, this), /*#__PURE__*/_jsxDEV(\"circle\", {\n                      cx: x + timePosition,\n                      cy: y - normalizedHeight,\n                      r: 2,\n                      fill: \"#4CAF50\"\n                    }, void 0, false, {\n                      fileName: _jsxFileName,\n                      lineNumber: 2086,\n                      columnNumber: 29\n                    }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n                      x: x + timePosition,\n                      y: y + 12,\n                      textAnchor: \"middle\",\n                      fill: \"#666\",\n                      fontSize: \"10px\",\n                      children: [event.time.toFixed(1), \"s\"]\n                    }, void 0, true, {\n                      fileName: _jsxFileName,\n                      lineNumber: 2093,\n                      columnNumber: 29\n                    }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n                      x: x + timePosition,\n                      y: y - normalizedHeight - 5,\n                      textAnchor: \"middle\",\n                      fill: \"#4CAF50\",\n                      fontSize: \"8px\",\n                      children: event.value.toFixed(1)\n                    }, void 0, false, {\n                      fileName: _jsxFileName,\n                      lineNumber: 2103,\n                      columnNumber: 29\n                    }, this)]\n                  }, `pump-event-${i}`, true, {\n                    fileName: _jsxFileName,\n                    lineNumber: 2075,\n                    columnNumber: 27\n                  }, this);\n                }), /*#__PURE__*/_jsxDEV(\"line\", {\n                  x1: currentTime / maxTime * 80,\n                  y1: -25,\n                  x2: currentTime / maxTime * 80,\n                  y2: 15,\n                  stroke: \"red\",\n                  strokeWidth: 1,\n                  strokeDasharray: \"2,2\"\n                }, void 0, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 2116,\n                  columnNumber: 23\n                }, this)]\n              }, void 0, true, {\n                fileName: _jsxFileName,\n                lineNumber: 2057,\n                columnNumber: 21\n              }, this)]\n            }, `pump-speed-${node.id}`, true, {\n              fileName: _jsxFileName,\n              lineNumber: 2044,\n              columnNumber: 19\n            }, this);\n          }\n          return null;\n        })]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1850,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1849,\n      columnNumber: 9\n    }, this), selectedNode && (selectedNode.type === 'pump' || ((_selectedNode$data = selectedNode.data) === null || _selectedNode$data === void 0 ? void 0 : _selectedNode$data.type) === 'pump') && /*#__PURE__*/_jsxDEV(DraggablePanel, {\n      initialPosition: pumpPanelPosition,\n      title: `Pump Controls - ${selectedNode.label || selectedNode.id}`,\n      children: /*#__PURE__*/_jsxDEV(PumpActions, {\n        node: selectedNode,\n        nodes: nodes,\n        edges: edges,\n        onAction: handleNodeAction\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 2140,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 2136,\n      columnNumber: 9\n    }, this), selectedNode && (selectedNode.type === 'USBSpectrometer' || ((_selectedNode$data2 = selectedNode.data) === null || _selectedNode$data2 === void 0 ? void 0 : _selectedNode$data2.type) === 'USBSpectrometer') && /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [console.log('Rendering USBSpectrometer component for node:', selectedNode), /*#__PURE__*/_jsxDEV(USBSpectrometer, {\n        detector: selectedNode,\n        detectorId: selectedNode.id,\n        detectorName: selectedNode.label || selectedNode.id,\n        onClose: () => setSelectedNode(null),\n        initialPosition: {\n          x: 150,\n          y: 100\n        },\n        isVisible: true\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 2151,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true), selectedNode && (selectedNode.type === 'MQTTSpectrometer' || ((_selectedNode$data3 = selectedNode.data) === null || _selectedNode$data3 === void 0 ? void 0 : _selectedNode$data3.type) === 'MQTTSpectrometer') && /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [console.log('Rendering SpectrometerMQTT component for node:', selectedNode), /*#__PURE__*/_jsxDEV(SpectrometerMQTT, {\n        detector: selectedNode,\n        detectorId: selectedNode.id,\n        detectorName: selectedNode.label || selectedNode.id,\n        onClose: () => setSelectedNode(null),\n        initialPosition: {\n          x: 150,\n          y: 100\n        },\n        isVisible: true\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 2164,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true), /*#__PURE__*/_jsxDEV(\"style\", {\n      children: `\n          .node-actions {\n            position: fixed;\n            top: 20px;\n            right: 20px;\n            background: black;\n            padding: 20px;\n            border: 1px solid #ccc;\n            border-radius: 5px;\n            box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n          }\n          .node-actions h3 {\n            margin: 0 0 15px 0;\n            color: #333;\n          }\n          .node-actions button {\n            margin: 5px;\n            padding: 8px 16px;\n            background: #4CAF50;\n            color: white;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n          }\n          .node-actions button:disabled {\n            background: #ccc;\n            cursor: not-allowed;\n          }\n          .node-actions input {\n            margin: 5px;\n            padding: 8px;\n            border: 1px solid #ccc;\n            border-radius: 4px;\n            width: 80px;\n          }\n          .move-controls {\n            display: flex;\n            flex-direction: column;\n            gap: 10px;\n            margin-top: 10px;\n          }\n          .input-group {\n            display: flex;\n            align-items: center;\n            gap: 10px;\n          }\n          .input-group label {\n            min-width: 100px;\n            text-align: right;\n            color: #666;\n          }\n        `\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 2175,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 1682,\n    columnNumber: 5\n  }, this);\n};\n_s(Simulation, \"2TFKLKlLcJIWI7CReehdw9iEJ4k=\", false, function () {\n  return [useButtonStyles];\n});\n_c = Simulation;\nexport default Simulation;\nvar _c;\n$RefreshReg$(_c, \"Simulation\");","map":{"version":3,"names":["React","useState","useEffect","useCallback","useRef","PumpActions","DraggablePanel","convertToHardwareValuesPump","useButtonStyles","backgroundVariants","findOutletNode","findFurthestNode","orderNodesByDistance","calculateEdgeVolume","getVolumeBetweenNodes","findConnectedPump","getPumpSpeed","getPumpsBetweenPositions","cleanAndSortEventList","getPumpSpeedAtTime","sendEventsToDevices","setOfMainLineNodes","setOfSecondaryLineNodes","SvgDefs","calculateEdgePoints","createLabels","USBSpectrometer","SpectrometerMQTT","jsxDEV","_jsxDEV","Fragment","_Fragment","Simulation","nodes","edges","droplets","selectedCarrierPumps","onBack","onNext","_s","_dropletHistory$curre","_selectedNode$data","_selectedNode$data2","_selectedNode$data3","buttonVariants","graphData","setGraphData","links","simulationDroplets","setSimulationDroplets","isSimulationRunning","setIsSimulationRunning","key","setKey","currentTime","setCurrentTime","timeScale","setTimeScale","animationFrameRef","lastFrameTimeRef","currentBlockDroplets","setCurrentBlockDroplets","dropletHistory","setDropletHistory","currentTimepoint","setCurrentTimepoint","pumpEvents","setPumpEvents","displayPumpSpeeds","setDisplayPumpSpeeds","displayNodeIds","setDisplayNodeIds","displayDropletInfo","setDisplayDropletInfo","displayDropletGaps","setDisplayDropletGaps","displayEdgeLabels","setDisplayEdgeLabels","isDisplayMenuOpen","setDisplayMenuOpen","displayTimelineDropletInfo","setDisplayTimelineDropletInfo","displayMenuRef","selectedNode","setSelectedNode","ws","setWs","pumpPanelPosition","setPumpPanelPosition","x","window","innerWidth","y","visiblePumpPanel","setVisiblePumpPanel","console","log","length","map","node","_node$data","id","type","dataType","data","websocket","WebSocket","onopen","onerror","error","close","sendingEventsToDevices","generateEventList","eventType","calculateVolumesBetweenThermostats","outletNode","visited","Set","queue","thermostatVolumes","currentNodeId","accumulatedVolume","thermostatPath","shift","currentNode","find","n","has","add","updatedPath","push","startThermostatId","endThermostatId","volume","connectedEdges","filter","link","source","target","edge","nextNodeId","nextNode","edgeVolume","divideDropletsIntoBlocks","thermostatId","totalVolume","reduce","acc","droplet","actualVolume","temperature","time","furthestNode","volumeToFurthestNode","blocks","currentBlock","finalizeBlock","lastDroplet","surfixParam","parameters","p","name","value","Math","max","i","_droplet$parameters$f","_droplet$parameters$f2","_droplet$parameters$f3","_droplet$parameters$f4","_droplet$parameters$f5","relevantVolume","tv","dropletVolume","printDropletFrontPositionsAndSpeeds","forEach","frontVolumetricPosition","frontTimeToReachNextNode","frontVolumetricDistanceToNextNode","rearVolumetricPosition","rearTimeToReachNextNode","rearVolumetricDistanceToNextNode","frontNextNodeID","rearNextNodeID","extractPumpEvents","eventList","flat","event","sort","a","b","recalculateEventListForDevices","deviceEventMap","Map","convertPumpEvent","deviceProperties","_deviceProperties$fin","_deviceProperties$fin2","_deviceProperties$fin3","_deviceProperties$fin4","syringeDiameter","default","syringeLength","stepsPerRevolution","lead","syringeArea","PI","pow","linearSpeed","abs","stepsPerMm","stepsPerSecond","delayMicroseconds","round","delay","convertThermostatEvent","convertLedEvent","intensity","convertDetectorEvent","setting","deviceEventList","targetId","deviceNode","deviceEvents","properties","warn","Boolean","set","Array","from","values","isArray","orderedNodes","dropletSnapshot","dropletWithParams","d","volumetricSpeedParam","commonVolumetricSpeed","inletVolumetricSpeed","outletVolumetricSpeed","pump","connectedPump","connectedPumpRatio","connectedPumpSpeedAtPause","pumpSpeedMultiplier","pauseLevel","carrierPumpConnector","connectorNode","position","_droplet$parameters$f6","_droplet$parameters$f7","prefixVolume","surfixVolume","frontVolumetricSpeed","rearVolumetricSpeed","frontVolumetricSpeedAtPause","rearVolumetricSpeedAtPause","stoppingDroplet","initialPumping","lastDropletRearPosition","outletNodePosition","volumetricPosition","timePassed","newTimePassed","smallestFrontTime","Infinity","smallestRearTime","smallestFrontTimeDroplet","smallestRearTimeDroplet","min","reachedNode","reachedNodeDistance","distance","index","indexOf","dropletsOlder","slice","dropletsNewer","ds","drops","JSON","parse","stringify","snappedNode","existingSnapshotIndex","findIndex","snapshot","nextEdge","_smallestFrontTimeDro","_smallestFrontTimeDro2","pumpRatio","param","nodeId","dropletDesiredVolume","_smallestFrontTimeDro3","_smallestFrontTimeDro4","rearTimeLeft","totalTimeLeft","thispumpspeed","accumulatedSpeed","reverse","editedNode","pumpBoost","speedDifference","accumulatedSpeedDecrease","pumpBreak","isFarthestThermostatOrLED","every","_smallestRearTimeDrop","waitTime","carrierPumpEvent","dropletState","_droplet$parameters$f8","prev","graphNodes","label","graphLinks","_edge$data","_edge$data$properties","_edge$data2","_edge$data2$propertie","diameter","nodesLength","linksLength","dropletsLength","mainLineNodes","includes","secondaryLineNodes","mainLineY","secondaryLineY","pumpSpacing","currentX","currentVolumetricPosition","graphNode","e","nodesByDistance","pumpOffset","Object","entries","connectedEdge","connectedNodeId","connectedMainNode","thermoVol","dropletsCopy","eventListForDevices","startSimulation","current","stopSimulation","cancelAnimationFrame","restartSimulation","prevKey","getNodeColor","volumetricToXPosition","_graphData$nodes$find","_graphData$nodes$find2","outletX","furthestX","isNaN","undefined","clampedPosition","scaledX","isFinite","updateDropletPositions","timestamp","requestAnimationFrame","deltaTime","simulationDeltaTime","prevTime","newTime","lastHistoryTime","currentState","interpolateDropletState","updatedDroplets","frontX","rearX","dropletId","frontPosition","rearPosition","speed","state","beforeState","afterState","fraction","beforeDroplet","afterDroplet","jumpToTimepoint","nextTimepoint","previousTimepoint","handleNodeClick","_node$data2","_node$data3","nodeType","handleNodeAction","action","togglePumpSpeeds","toggleNodeIds","toggleDropletInfo","toggleDropletGaps","toggleEdgeLabels","toggleDisplayMenu","toggleTimelineDropletInfo","handleClickOutside","contains","document","addEventListener","removeEventListener","togglePumpPanel","pumpId","styles","container","mainBackground","padding","minHeight","dropletInfo","borderRadius","fontSize","panelBackground","color","minWidth","timelineContainer","display","flexDirection","gap","marginBottom","timeInput","width","inputBackground","marginLeft","buttonGroup","marginTop","timelineControls","timeControls","sliderContainer","alignItems","borderBottom","paddingBottom","timeStepButtons","justifyContent","timeScaleContainer","borderTop","paddingTop","svgContainer","background","navigationButtons","timeSlider","height","WebkitAppearance","appearance","outline","opacity","transition","cursor","displayMenuButton","infoButton","displayMenu","top","right","backgroundColor","border","zIndex","boxShadow","menuItem","checkmark","fontWeight","sliderStyle","style","children","onChange","Number","disabled","className","fileName","_jsxFileName","lineNumber","columnNumber","flexWrap","_graphData$nodes$find3","_graphData$nodes$find4","onClick","secondaryButton","marginRight","toFixed","primaryButton","ref","sourceNode","targetNode","midX","midY","x1","y1","x2","y2","stroke","strokeWidth","textAnchor","fill","cx","cy","r","centerX","distanceInfo","nextDropletFront","distanceLabelX","strokeLinecap","strokeDasharray","_dropletHistory","currentSpeed","maxTime","pumpSpecificEvents","transform","arr","nextEvent","timePosition","nextTimePosition","maxSpeed","normalizedHeight","initialPosition","title","onAction","detector","detectorId","detectorName","onClose","isVisible","_c","$RefreshReg$"],"sources":["E:/flow chemistry/fluidicGUI/frontend/fluidicgui/src/components/Simulation/Simulation.js"],"sourcesContent":["import React, { useState, useEffect, useCallback, useRef } from 'react';\r\nimport PumpActions from './NodeActions/PumpActions';\r\nimport DraggablePanel from './DraggablePanel';\r\nimport { convertToHardwareValuesPump } from '../../utils/pumpCalculations';\r\nimport { useButtonStyles } from '../../styles/ButtonStyleProvider';\r\nimport { backgroundVariants } from '../../styles/backgroundStyles';\r\nimport {\r\n  findOutletNode,\r\n  findFurthestNode,\r\n  orderNodesByDistance,\r\n  calculateEdgeVolume,\r\n  getVolumeBetweenNodes,\r\n  findConnectedPump,\r\n  getPumpSpeed,\r\n  getPumpsBetweenPositions,\r\n  cleanAndSortEventList,\r\n  getPumpSpeedAtTime,\r\n  sendEventsToDevices,\r\n  setOfMainLineNodes,\r\n  setOfSecondaryLineNodes\r\n} from '../../utils/simulationUtils';\r\nimport './simulation.css'; // We'll create this CSS file\r\nimport SvgDefs from './SvgDefs';\r\nimport { calculateEdgePoints, createLabels } from '../../utils/flowchartUtils';\r\nimport USBSpectrometer from './USBSpectrometer';\r\nimport SpectrometerMQTT from './SpectrometerMQTT';\r\n\r\nconst Simulation = ({ nodes = [], edges = [], droplets = [], selectedCarrierPumps = [], onBack, onNext }) => {\r\n  const buttonVariants = useButtonStyles();\r\n  const [graphData, setGraphData] = useState({ nodes: [], links: [] });\r\n  const [simulationDroplets, setSimulationDroplets] = useState([]);\r\n  const [isSimulationRunning, setIsSimulationRunning] = useState(false);\r\n  const [key, setKey] = useState(0);\r\n  const [currentTime, setCurrentTime] = useState(0);\r\n  const [timeScale, setTimeScale] = useState(1); // Default 1x speed\r\n  const animationFrameRef = useRef();\r\n  const lastFrameTimeRef = useRef();\r\n  const [currentBlockDroplets, setCurrentBlockDroplets] = useState([]);\r\n  const [dropletHistory, setDropletHistory] = useState([]);\r\n  const [currentTimepoint, setCurrentTimepoint] = useState(0);\r\n  const [pumpEvents, setPumpEvents] = useState([]);\r\n  const [displayPumpSpeeds, setDisplayPumpSpeeds] = useState(false);\r\n  const [displayNodeIds, setDisplayNodeIds] = useState(false);\r\n  const [displayDropletInfo, setDisplayDropletInfo] = useState(false);\r\n  const [displayDropletGaps, setDisplayDropletGaps] = useState(true);\r\n  const [displayEdgeLabels, setDisplayEdgeLabels] = useState(false);\r\n  const [isDisplayMenuOpen, setDisplayMenuOpen] = useState(false);\r\n  const [displayTimelineDropletInfo, setDisplayTimelineDropletInfo] = useState(false);\r\n  const displayMenuRef = useRef(null);\r\n  const [selectedNode, setSelectedNode] = useState(null);\r\n  const [ws, setWs] = useState(null);\r\n  const [pumpPanelPosition, setPumpPanelPosition] = useState({ x: window.innerWidth - 300, y: 100 });\r\n  const [visiblePumpPanel, setVisiblePumpPanel] = useState(null);\r\n\r\n  // Add at the beginning of the component, after the state initialization\r\n  useEffect(() => {\r\n    // Log all nodes and their types for debugging\r\n    console.log('All nodes:', nodes);\r\n    if (nodes && nodes.length > 0) {\r\n      console.log('Node types in simulation:', nodes.map(node => ({\r\n        id: node.id,\r\n        type: node.type,\r\n        dataType: node.data?.type\r\n      })));\r\n    }\r\n  }, [nodes]);\r\n\r\n  useEffect(() => {\r\n    // Create WebSocket connection\r\n    const websocket = new WebSocket('ws://localhost:4000');\r\n    \r\n    websocket.onopen = () => {\r\n      console.log('Connected to WebSocket server');\r\n    };\r\n\r\n    websocket.onerror = (error) => {\r\n      console.error('WebSocket error:', error);\r\n    };\r\n\r\n    setWs(websocket);\r\n\r\n    // Cleanup on unmount\r\n    return () => {\r\n      if (websocket) {\r\n        websocket.close();\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  const sendingEventsToDevices = () => {\r\n    sendEventsToDevices(pumpEvents, ws, nodes);\r\n    // Reset simulation state\r\n    setCurrentTime(0);\r\n    setCurrentTimepoint(0);\r\n    setIsSimulationRunning(true);\r\n    setDropletHistory([]);\r\n    // Generate new event list\r\n    generateEventList([{ droplets: droplets }]);\r\n  };\r\n\r\n  const eventType = ['setPumpSpeed', 'setThermostatTemperature', 'setLedIntensity', 'wait', 'blockEnd'];\r\n\r\n  const calculateVolumesBetweenThermostats = (graphData) => {\r\n  \r\n    // Find outlet node first\r\n    const outletNode = findOutletNode(graphData.nodes);\r\n  \r\n    const visited = new Set();\r\n    const queue = [[outletNode.id, 0, []]]; // [nodeId, accumulated volume, path of thermostats]\r\n    const thermostatVolumes = [];\r\n  \r\n    while (queue.length > 0) {\r\n      let [currentNodeId, accumulatedVolume, thermostatPath] = queue.shift();\r\n      const currentNode = graphData.nodes.find(n => n.id === currentNodeId);\r\n  \r\n      if (!currentNode) continue;\r\n      \r\n      // Track all visited nodes to prevent infinite loops\r\n      if (visited.has(currentNodeId)) continue;\r\n      visited.add(currentNodeId);\r\n  \r\n      // If we found a thermostat, add it to the path\r\n      let updatedPath = [...thermostatPath];\r\n      if (currentNode.type === 'thermostat') {\r\n        if (thermostatPath.length > 0) {\r\n          thermostatVolumes.push({\r\n            startThermostatId: thermostatPath[thermostatPath.length - 1],\r\n            endThermostatId: currentNodeId,\r\n            volume: accumulatedVolume\r\n          });\r\n        }\r\n        updatedPath.push(currentNodeId);\r\n        // Reset accumulated volume after finding a thermostat\r\n        accumulatedVolume = 0;\r\n      }\r\n  \r\n      // Find all connected edges and nodes\r\n      const connectedEdges = graphData.links.filter(link => \r\n        link.source === currentNodeId || link.target === currentNodeId\r\n      );\r\n  \r\n      for (const edge of connectedEdges) {\r\n        const nextNodeId = edge.source === currentNodeId ? edge.target : edge.source;\r\n        const nextNode = graphData.nodes.find(n => n.id === nextNodeId);\r\n        \r\n        // Skip paths to pumps\r\n        if (nextNode && nextNode.type !== 'pump') {\r\n          const edgeVolume = calculateEdgeVolume(edge);\r\n          queue.push([nextNodeId, accumulatedVolume + edgeVolume, updatedPath]);\r\n        }\r\n      }\r\n    }\r\n  \r\n    return thermostatVolumes;\r\n  };\r\n//add something to handle lack of thermostat\r\n  const divideDropletsIntoBlocks = (droplets, thermostatVolumes) => {\r\n\r\n    if (thermostatVolumes.length === 0) {\r\n      return [{\r\n        droplets: droplets,\r\n        thermostatId: null,\r\n        totalVolume: droplets.reduce((acc, droplet) => acc + droplet.actualVolume, 0),\r\n        temperature: null,\r\n        time: null\r\n      }];\r\n    }\r\n\r\n    const furthestNode = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links);\r\n\r\n    const volumeToFurthestNode = getVolumeBetweenNodes(thermostatVolumes[0].endThermostatId, furthestNode.id, graphData.nodes, graphData.links);\r\n    \r\n    if (!droplets.length || !thermostatVolumes.length) return [];\r\n\r\n    const blocks = [];\r\n    let currentBlock = {\r\n      droplets: [],\r\n      thermostatId: thermostatVolumes[0].endThermostatId,\r\n      totalVolume: 0,\r\n      temperature: null,\r\n      time: null\r\n    };\r\n\r\n    // Helper to finalize a block and start a new one\r\n    const finalizeBlock = (thermostatId, temperature, time) => {\r\n      if (currentBlock.droplets.length > 0) {\r\n        // Add volumeToFurthestNode to the surfixVolume of the last droplet in the block\r\n        const lastDroplet = currentBlock.droplets[currentBlock.droplets.length - 1];\r\n        const surfixParam = lastDroplet.parameters.find(p => p.name === 'surfixVolume');\r\n        if (surfixParam) {\r\n          surfixParam.value = Math.max(volumeToFurthestNode, surfixParam.value);\r\n        } else {\r\n          lastDroplet.parameters.push({\r\n            name: 'surfixVolume',\r\n            value: volumeToFurthestNode\r\n          });\r\n        }\r\n        \r\n        blocks.push({ ...currentBlock });\r\n      }\r\n      currentBlock = {\r\n        droplets: [],\r\n        thermostatId: thermostatId,\r\n        totalVolume: 0,\r\n        temperature: temperature,\r\n        time: time\r\n      };\r\n    };\r\n\r\n    // Process droplets in order\r\n    for (let i = 0; i < droplets.length; i++) {\r\n      const droplet = droplets[i];\r\n      const temperature = droplet.parameters.find(p => p.name === 'temperature')?.value;\r\n      const time = droplet.parameters.find(p => p.name === 'time')?.value;\r\n\r\n      // Start new block if temperature or time changes, or if volume limit exceeded\r\n      const relevantVolume = thermostatVolumes.find(tv => \r\n        tv.startThermostatId === currentBlock.thermostatId || \r\n        tv.endThermostatId === currentBlock.thermostatId\r\n      );\r\n\r\n      let dropletVolume = droplet.parameters.find(p => p.name === 'volume')?.value;\r\n      dropletVolume += droplet.parameters.find(p => p.name === 'prefixVolume')?.value;\r\n      \r\n\r\n      if (\r\n        currentBlock.temperature !== temperature ||\r\n        currentBlock.time !== time ||\r\n        (relevantVolume && currentBlock.totalVolume + dropletVolume > relevantVolume.volume)\r\n      ) {\r\n        finalizeBlock(thermostatVolumes[0].endThermostatId, temperature, time);\r\n      }\r\n      dropletVolume += droplet.parameters.find(p => p.name === 'surfixVolume')?.value;\r\n      // Add droplet to current block\r\n      currentBlock.droplets.push(droplet);\r\n      currentBlock.totalVolume += dropletVolume;\r\n      currentBlock.temperature = temperature;\r\n      currentBlock.time = time;\r\n    }\r\n\r\n    // Finalize last block\r\n    finalizeBlock(null, null, null);\r\n\r\n    return blocks;\r\n  };\r\n\r\n  function printDropletFrontPositionsAndSpeeds(droplets) {\r\n    droplets.forEach(droplet => {\r\n      console.log(`Droplet ID: ${droplet.id}, Front Volumetric Position: ${droplet.frontVolumetricPosition}, Front time to next node  : ${droplet.frontTimeToReachNextNode}, Front Volumetric Distance to next node: ${droplet.frontVolumetricDistanceToNextNode}, Rear Volumetric Position: ${droplet.rearVolumetricPosition}, Rear time to next node: ${droplet.rearTimeToReachNextNode}, Rear Volumetric Distance to next node: ${droplet.rearVolumetricDistanceToNextNode}, frontNextNodeID: ${droplet.frontNextNodeID}, rearNextNodeID: ${droplet.rearNextNodeID}`);\r\n    });\r\n  }\r\n\r\n  const extractPumpEvents = (eventList) => {\r\n    // eventList is now an array of arrays, where each inner array contains events for a specific pump\r\n    return eventList\r\n      .flat() // Flatten the array of arrays\r\n      .filter(event => event.type === 'setPumpSpeed')\r\n      .sort((a, b) => a.time - b.time);\r\n  };\r\n\r\n  const recalculateEventListForDevices = (eventList) => {\r\n    const deviceEventMap = new Map();\r\n\r\n    const convertPumpEvent = (event, deviceProperties) => {\r\n      // Find properties by name from the properties array\r\n      const syringeDiameter = deviceProperties.find(p => p.name === 'diameter')?.default || 0;\r\n      const syringeLength = deviceProperties.find(p => p.name === 'length')?.default || 0;\r\n      const stepsPerRevolution = deviceProperties.find(p => p.name === 'steps per revolution')?.default || 0;\r\n      const lead = deviceProperties.find(p => p.name === 'lead')?.default || 0;\r\n\r\n      const syringeArea = Math.PI * Math.pow(syringeDiameter / 2, 2);\r\n      const linearSpeed = Math.abs(event.value) / syringeArea;\r\n      const stepsPerMm = stepsPerRevolution / lead;\r\n      const stepsPerSecond = linearSpeed * stepsPerMm;\r\n      const delayMicroseconds = stepsPerSecond > 0 ? \r\n        Math.round(1000000 / stepsPerSecond) : \r\n        0;\r\n\r\n      return {\r\n        target: event.target,\r\n        time: Math.round(event.time * 1000000),\r\n        delay: delayMicroseconds\r\n      };\r\n    };\r\n\r\n    const convertThermostatEvent = (event, deviceProperties) => {\r\n      // Placeholder for thermostat conversion logic\r\n      return {\r\n        target: event.target,\r\n        time: Math.round(event.time * 1000000),\r\n        temperature: event.value,\r\n        // Add other thermostat-specific parameters here\r\n      };\r\n    };\r\n\r\n    const convertLedEvent = (event, deviceProperties) => {\r\n      // Placeholder for LED conversion logic\r\n      return {\r\n        target: event.target,\r\n        time: Math.round(event.time * 1000000),\r\n        intensity: event.value,\r\n        // Add other LED-specific parameters here\r\n      };\r\n    };\r\n\r\n    const convertDetectorEvent = (event, deviceProperties) => {\r\n      // Placeholder for detector conversion logic\r\n      return {\r\n        target: event.target,\r\n        time: Math.round(event.time * 1000000),\r\n        setting: event.value,\r\n        // Add other detector-specific parameters here\r\n      };\r\n    };\r\n\r\n    eventList.forEach(deviceEventList => {\r\n      if (!deviceEventList.length) return;\r\n\r\n      const targetId = deviceEventList[0].target;\r\n      const deviceNode = nodes.find(node => node.id === targetId);\r\n      \r\n      if (!deviceNode || !deviceNode.data) {\r\n        console.error(`Device node or data not found for ID: ${targetId}`);\r\n        return;\r\n      }\r\n\r\n      const deviceEvents = deviceEventList.map(event => {\r\n        switch (event.type) {\r\n          case 'setPumpSpeed':\r\n            return convertPumpEvent(event, deviceNode.data.properties);\r\n          \r\n          case 'setThermostatTemperature':\r\n            return convertThermostatEvent(event, deviceNode.data.properties);\r\n          \r\n          case 'setLedIntensity':\r\n            return convertLedEvent(event, deviceNode.data.properties);\r\n          \r\n          case 'setDetectorSetting':\r\n            return convertDetectorEvent(event, deviceNode.data.properties);\r\n          \r\n          default:\r\n            console.warn(`Unknown event type: ${event.type}`);\r\n            return null;\r\n        }\r\n      }).filter(Boolean); // Remove any null events\r\n\r\n      if (deviceEvents.length > 0) {\r\n        deviceEventMap.set(targetId, deviceEvents);\r\n      }\r\n    });\r\n    console.log('deviceEventMap: ', Array.from(deviceEventMap.values()));\r\n    return Array.from(deviceEventMap.values());\r\n  };\r\n\r\n  const generateEventList = (blocks) => {\r\n    // Early exit if blocks array is invalid\r\n    if (!blocks || !Array.isArray(blocks) || blocks.length === 0) {\r\n      console.warn('No valid blocks found for event generation');\r\n      return [];\r\n    }\r\n\r\n    const orderedNodes = orderNodesByDistance(findOutletNode(graphData.nodes), graphData.nodes, graphData.links);\r\n    console.log('orderedNodes: ', orderedNodes);\r\n    \r\n    // Early exit if no ordered nodes\r\n    if (!orderedNodes || orderedNodes.length === 0) {\r\n      console.warn('No ordered nodes found for event generation');\r\n      return [];\r\n    }\r\n    \r\n    let eventList = [];\r\n    let dropletSnapshot = [];\r\n    \r\n    // Validate block droplets\r\n    if (!blocks[0] || !blocks[0].droplets || !Array.isArray(blocks[0].droplets) || blocks[0].droplets.length === 0) {\r\n      console.warn('No valid droplets found in blocks for event generation');\r\n      return [];\r\n    }\r\n    \r\n    const i = 0;\r\n    const currentBlockDroplets = blocks[i].droplets;\r\n    \r\n    // Add fallback for volumetricSpeed in case it's not found\r\n    const dropletWithParams = currentBlockDroplets.find(d => d && d.parameters && Array.isArray(d.parameters));\r\n    if (!dropletWithParams) {\r\n      console.warn('No droplet with valid parameters found');\r\n      return [];\r\n    }\r\n    \r\n    // Make sure we can find the volumetricSpeed parameter or use a default\r\n    const volumetricSpeedParam = dropletWithParams.parameters.find(p => p && p.name === 'volumetricSpeed');\r\n    const commonVolumetricSpeed = volumetricSpeedParam?.value || 1;\r\n    console.log('Using volumetricSpeed:', commonVolumetricSpeed);\r\n    \r\n    //adds some parameters to nodes\r\n    orderedNodes.forEach(node => {\r\n      node.inletVolumetricSpeed = commonVolumetricSpeed;\r\n      node.outletVolumetricSpeed = commonVolumetricSpeed;\r\n      const pump = findConnectedPump(node.node.id, graphData.nodes, graphData.links);\r\n      if (pump) {\r\n        node.connectedPump = pump;\r\n      }\r\n      else {\r\n        node.connectedPump = 0;\r\n      }\r\n      node.connectedPumpRatio = 0;\r\n      node.connectedPumpSpeedAtPause = 0;\r\n      node.pumpSpeedMultiplier = 1;\r\n      //node.requestedRatio = 0;\r\n      node.pauseLevel = 0;\r\n\r\n    });\r\n    //ustawia carrier pump na odpowiednią predkość\r\n    const carrierPumpConnector = graphData.links.find(link => link.source === selectedCarrierPumps[0]).target;\r\n    if (carrierPumpConnector) {\r\n      const connectorNode = orderedNodes.find(node => node.node.id === carrierPumpConnector);\r\n      connectorNode.inletVolumetricSpeed = commonVolumetricSpeed;\r\n      connectorNode.outletVolumetricSpeed = commonVolumetricSpeed;\r\n      connectorNode.connectedPump = graphData.nodes.find(node => node.id === selectedCarrierPumps[0]);\r\n      connectorNode.connectedPumpRatio = 1;\r\n      connectorNode.connectedPumpSpeedAtPause = commonVolumetricSpeed;\r\n      //connectorNode.requestedRatio = 0;\r\n      connectorNode.pauseLevel = 0;\r\n    }\r\n    let event = { //it is ok\r\n      type: 'setPumpSpeed',\r\n      target: selectedCarrierPumps[0],\r\n      time: 0,\r\n      value: commonVolumetricSpeed\r\n    };\r\n    eventList.push(event);\r\n\r\n    orderedNodes.filter(node => node.node.type === 'pump' && node.node.id !== selectedCarrierPumps[0]).forEach(pump => {\r\n      event = {//it is ok\r\n        type: 'setPumpSpeed',\r\n        target: pump.node.id,\r\n        time: 0,\r\n        value: 0\r\n      };\r\n      eventList.push(event);\r\n      \r\n    });\r\n\r\n    orderedNodes.filter(node => node.node.type !== 'pump' ).forEach(pump => {\r\n      \r\n    });\r\n\r\n\r\n    let position = -0.001;\r\n    //prepares all droplets in block and calculates some parameters\r\n    currentBlockDroplets.forEach(droplet => {\r\n      const prefixVolume = droplet.parameters.find(p => p.name === 'prefixVolume')?.value;\r\n      const surfixVolume = droplet.parameters.find(p => p.name === 'surfixVolume')?.value;\r\n\r\n      droplet.frontVolumetricSpeed = commonVolumetricSpeed;\r\n      droplet.rearVolumetricSpeed = commonVolumetricSpeed;\r\n      droplet.frontVolumetricPosition = position - prefixVolume;\r\n      droplet.rearVolumetricPosition = droplet.frontVolumetricPosition;\r\n      droplet.frontVolumetricDistanceToNextNode = Math.abs(droplet.frontVolumetricPosition);\r\n      droplet.rearVolumetricDistanceToNextNode = Math.abs(droplet.rearVolumetricPosition); \r\n      droplet.frontTimeToReachNextNode = 0;\r\n      droplet.rearTimeToReachNextNode = 0;\r\n      droplet.frontNextNodeID = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id;\r\n      droplet.rearNextNodeID = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id;\r\n      droplet.pumpSpeedMultiplier = 1;\r\n      droplet.pauseLevel = 0;\r\n      droplet.frontVolumetricSpeedAtPause = 0;\r\n      droplet.rearVolumetricSpeedAtPause = 0;\r\n      droplet.stoppingDroplet = false;\r\n      droplet.initialPumping = false;\r\n\r\n      position -= ( prefixVolume + surfixVolume);\r\n    });\r\n    console.log('findFurthestNode: ', findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id);\r\n    console.log('Droplet positions initialized, nodes ready');\r\n\r\n    let lastDropletRearPosition = currentBlockDroplets[currentBlockDroplets.length - 1].rearVolumetricPosition;\r\n    let outletNodePosition = orderedNodes[0].node.volumetricPosition; \r\n    let timePassed = 0; //in s\r\n    let newTimePassed = 0;\r\n\r\n    // Simulate the movement of droplets in the current block\r\n    currentBlockDroplets.forEach(droplet => {\r\n      droplet.frontTimeToReachNextNode = Math.abs(droplet.frontVolumetricDistanceToNextNode / droplet.frontVolumetricSpeed);\r\n      droplet.rearTimeToReachNextNode = Math.abs(droplet.rearVolumetricDistanceToNextNode / droplet.rearVolumetricSpeed);\r\n    });\r\n\r\n    while (lastDropletRearPosition < outletNodePosition) {\r\n      \r\n      let smallestFrontTime = Infinity;\r\n      let smallestRearTime = Infinity;\r\n      let smallestFrontTimeDroplet = [];\r\n      let smallestRearTimeDroplet = [];\r\n\r\n      currentBlockDroplets.forEach(droplet => {// Update the smallest front and rear times and associated droplet(s) based on the current droplet's front and rear times to reach the next node.\r\n        \r\n        if (Math.abs(droplet.frontTimeToReachNextNode) < smallestFrontTime) {\r\n          smallestFrontTime = Math.abs(droplet.frontTimeToReachNextNode);\r\n          smallestFrontTimeDroplet = [droplet];\r\n        }\r\n        else if (Math.abs(droplet.frontTimeToReachNextNode) === smallestFrontTime) {\r\n          smallestFrontTimeDroplet.push(droplet);\r\n        }\r\n        if (Math.abs(droplet.rearTimeToReachNextNode) < smallestRearTime) {\r\n          smallestRearTime = Math.abs(droplet.rearTimeToReachNextNode);\r\n          smallestRearTimeDroplet = [droplet];\r\n        }\r\n        else if (Math.abs(droplet.rearTimeToReachNextNode) === smallestRearTime) {\r\n          smallestRearTimeDroplet.push(droplet);\r\n        }\r\n      });\r\n\r\n      newTimePassed += Math.min(Math.abs(smallestFrontTime), Math.abs(smallestRearTime));\r\n\r\n      if (smallestFrontTime === smallestRearTime) {//przypadek w ktorym wiele kropel ma ten sam czas do przejścia do nastepnego noda, rzadki\r\n        \r\n        if (smallestFrontTimeDroplet.length > 1 || smallestRearTimeDroplet.length > 1) {//sprawdź czy wśród nich jest kropla z rear i front\r\n          console.log('Multiple droplets have reached the next node simultaneously');\r\n          console.log('smallestFrontTimeDroplet: ', smallestFrontTimeDroplet);\r\n          console.log('smallestRearTimeDroplet: ', smallestRearTimeDroplet);\r\n          \r\n        }\r\n        else if (smallestFrontTimeDroplet[0] === smallestRearTimeDroplet[0]) {//przypadek gdy kropla ma 0 objętości\r\n          console.log('Both front and rear times are for the same droplet');\r\n          const reachedNode = orderedNodes.find(n => n.node.id === smallestFrontTimeDroplet[0].frontNextNodeID);\r\n          const reachedNodeDistance = orderedNodes.find(node => node.node.id === reachedNode.node.id).distance;\r\n          if (reachedNode.node.type === 'connector') {\r\n\r\n\r\n            const index = currentBlockDroplets.indexOf(smallestFrontTimeDroplet[0]);\r\n            const dropletsOlder = currentBlockDroplets.slice(0, index);\r\n            const dropletsNewer = currentBlockDroplets.slice(index + 1);\r\n\r\n            const ds = [];\r\n            ds.drops = JSON.parse(JSON.stringify(dropletsNewer)); // Create deep copy\r\n            ds.snappedNode = smallestFrontTimeDroplet[0].frontNextNodeID;\r\n            const existingSnapshotIndex = dropletSnapshot.findIndex(snapshot => snapshot.snappedNode === ds.snappedNode);\r\n            if (existingSnapshotIndex !== -1) {\r\n              dropletSnapshot[existingSnapshotIndex] = ds;\r\n            } else {\r\n              dropletSnapshot.push(ds);\r\n            }\r\n\r\n            //aktualizuje starsze krople\r\n            dropletsOlder.forEach(droplet => {\r\n              droplet.frontTimeToReachNextNode -= smallestFrontTime;\r\n              droplet.rearTimeToReachNextNode -= smallestFrontTime;\r\n              droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\r\n              droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\r\n              droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\r\n              droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\r\n            });\r\n\r\n            //aktualizuje kroplę\r\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\r\n            const nextEdge = graphData.links.find(link => link.source === smallestFrontTimeDroplet[0].frontNextNodeID && link.target === nextNode.node.id);\r\n\r\n            if (reachedNode.connectedPump !== null){\r\n              const pumpRatio = smallestFrontTimeDroplet[0].parameters.find(param => param.nodeId === reachedNode.connectedPump.id && param.name === 'ratio')?.value || 0;\r\n              const dropletDesiredVolume = smallestFrontTimeDroplet[0].parameters.find(param => param.name === 'volume')?.value || 0;\r\n              \r\n              reachedNode.connectedPumpRatio = pumpRatio;\r\n              //reachedNode.inletVolumetricSpeed = 0;\r\n              //smallestFrontTimeDroplet[0].frontVolumetricSpeed = reachedNode.outletVolumetricSpeed;\r\n              smallestFrontTimeDroplet[0].frontVolumetricSpeedAtPause = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n              smallestFrontTimeDroplet[0].rearVolumetricSpeedAtPause = smallestFrontTimeDroplet[0].rearVolumetricSpeed;\r\n              smallestFrontTimeDroplet[0].rearVolumetricSpeed = 0;\r\n              smallestFrontTimeDroplet[0].frontVolumetricPosition = reachedNode.node.volumetricPosition;\r\n              smallestFrontTimeDroplet[0].rearVolumetricPosition = reachedNode.node.volumetricPosition;\r\n              smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\r\n              smallestFrontTimeDroplet[0].rearVolumetricDistanceToNextNode = 0; \r\n              smallestFrontTimeDroplet[0].frontTimeToReachNextNode = smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode/smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n              smallestFrontTimeDroplet[0].rearTimeToReachNextNode = dropletDesiredVolume*pumpRatio/smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n              smallestFrontTimeDroplet[0].frontNextNodeID = nextNode.node.id;\r\n              //smallestFrontTimeDroplet[0].rearNextNodeID = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id;\r\n              smallestFrontTimeDroplet[0].pumpSpeedMultiplier = 1;\r\n              //smallestFrontTimeDroplet[0].pauseLevel = 0;\r\n              smallestFrontTimeDroplet[0].stoppingDroplet = true;\r\n              smallestFrontTimeDroplet[0].initialPumping = true;\r\n              if (reachedNode.connectedPump.id !==selectedCarrierPumps[0]) {\r\n                event={\r\n                  type: 'setPumpSpeed',\r\n                  target: reachedNode.connectedPump.id,\r\n                  time: newTimePassed,\r\n                  value: smallestFrontTimeDroplet[0].frontVolumetricSpeed\r\n                };\r\n                eventList.push(event);\r\n              }\r\n\r\n              //update newer droplets\r\n              dropletsNewer.forEach(droplet => {\r\n                droplet.pauseLevel += 1;\r\n                if (droplet.pauseLevel===1){\r\n                  droplet.frontVolumetricSpeedAtPause = droplet.frontVolumetricSpeed;\r\n                  if (droplet.stoppingDroplet !== true){\r\n                    droplet.rearVolumetricSpeedAtPause = droplet.rearVolumetricSpeed;\r\n                  }\r\n                }\r\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontVolumetricSpeed = 0;\r\n                droplet.rearVolumetricSpeed = 0;\r\n                droplet.frontTimeToReachNextNode += smallestFrontTimeDroplet[0].rearTimeToReachNextNode-smallestFrontTime;\r\n                droplet.rearTimeToReachNextNode += smallestFrontTimeDroplet[0].rearTimeToReachNextNode-smallestFrontTime;\r\n              });\r\n              getPumpsBetweenPositions(smallestFrontTimeDroplet[0].frontVolumetricPosition,-1, graphData.nodes, graphData.links).filter(pump => pump.id !== reachedNode.connectedPump.id, ).forEach(pump => {\r\n                \r\n                event={\r\n                  type: 'setPumpSpeed',\r\n                  target: pump.id,\r\n                  time: newTimePassed,\r\n                  value: 0\r\n                };\r\n                eventList.push(event);\r\n              });\r\n            }\r\n            \r\n          }\r\n          else if (reachedNode.type === 'thermostat' || reachedNode.type === 'LED') {\r\n            console.log('reachedNode is thermostat');\r\n          }\r\n          else if (reachedNode.type === 'outlet') {\r\n            console.log('reachedNode is outlet');\r\n          }\r\n          else if (reachedNode.type === 'detector' || reachedNode.type === 'USBSpectrometer' || reachedNode.type === 'MQTTSpectrometer') {\r\n            console.log('reachedNode is detector');\r\n          }\r\n        } \r\n        else {\r\n          console.log('Front and rear times are for different droplets');\r\n        }\r\n      } \r\n\r\n      else if (smallestFrontTime < smallestRearTime) { //przypadek gdzie przód jest przed tyłem\r\n        console.log('Front time is smaller than rear time');\r\n        if (smallestFrontTimeDroplet.length > 1) {\r\n          console.log(`Multiple droplets have reached the next node simultaneously`);\r\n          smallestFrontTimeDroplet.forEach(droplet => {\r\n            // Perform some action for each droplet in smallestFrontTimeDroplet\r\n          });\r\n        }\r\n        else { //przypadek gdy przód jednej kropelki dochodzi do noda\r\n          console.log(`Single droplet front has reached the next node`);\r\n          const reachedNode = orderedNodes.find(n => n.node.id === smallestFrontTimeDroplet[0].frontNextNodeID);\r\n          const reachedNodeDistance = orderedNodes.find(node => node.node.id === reachedNode.node.id).distance;\r\n\r\n          if (reachedNode.node.type === 'connector') { //przypadek gdy dochodzi do connectora\r\n            console.log('reachedNode is connector');\r\n\r\n            const index = currentBlockDroplets.indexOf(smallestFrontTimeDroplet[0]);\r\n            const dropletsOlder = currentBlockDroplets.slice(0, index);\r\n            const dropletsNewer = currentBlockDroplets.slice(index + 1);\r\n\r\n            //aktualizuje kroplę\r\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\r\n            const nextEdge = graphData.links.find(link => link.source === reachedNode.node.id && link.target === nextNode.node.id);\r\n\r\n            if (reachedNode.connectedPump.id !== null){\r\n\r\n              const pumpRatio = smallestFrontTimeDroplet[0].parameters.find(param => param.nodeId === reachedNode.connectedPump.id && param.name === 'ratio')?.value || 0;\r\n              const dropletDesiredVolume = smallestFrontTimeDroplet[0].parameters.find(param => param.name === 'volume')?.value || 0;\r\n              smallestFrontTimeDroplet[0].frontVolumetricPosition = reachedNode.node.volumetricPosition;\r\n              smallestFrontTimeDroplet[0].rearVolumetricPosition += smallestFrontTime * smallestFrontTimeDroplet[0].rearVolumetricSpeed;\r\n              smallestFrontTimeDroplet[0].actualVolume =smallestFrontTimeDroplet[0].frontVolumetricPosition-smallestFrontTimeDroplet[0].rearVolumetricPosition;\r\n              reachedNode.inletVolumetricSpeed = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n              reachedNode.connectedPumpRatio = pumpRatio;\r\n              smallestFrontTimeDroplet[0].rearTimeToReachNextNode -= smallestFrontTime;\r\n              smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\r\n              smallestFrontTimeDroplet[0].rearVolumetricDistanceToNextNode -= smallestFrontTime * smallestFrontTimeDroplet[0].rearVolumetricSpeed; \r\n\r\n              if (smallestFrontTimeDroplet[0].initialPumping === true){ //przypadek gdy kropla jest w pierwszej fazie pompowania (od 0uL)\r\n                console.log('Kropla jest w pierwszej fazie pompowania');\r\n                //smallestFrontTimeDroplet[0].initialPumping = false;\r\n                const rearTimeLeft = smallestFrontTimeDroplet[0].rearTimeToReachNextNode;\r\n                const totalTimeLeft = rearTimeLeft + smallestFrontTimeDroplet[0].actualVolume/commonVolumetricSpeed;\r\n                console.log('commonVolumetricSpeed: ', commonVolumetricSpeed);\r\n                console.log('smallestFrontTimeDroplet[0].actualVolume: ', smallestFrontTimeDroplet[0].actualVolume);\r\n                console.log('rearTimeLeft: ', rearTimeLeft);\r\n                console.log('totalTimeLeft: ', totalTimeLeft);\r\n                const thispumpspeed = pumpRatio*dropletDesiredVolume/totalTimeLeft;\r\n                console.log('thispumpspeed: ', thispumpspeed);\r\n                reachedNode.connectedPumpSpeedAtPause = thispumpspeed;\r\n              }\r\n\r\n              else {\r\n                console.log('Normalne pompowanie');\r\n                reachedNode.connectedPumpSpeedAtPause = (dropletDesiredVolume*pumpRatio) / (smallestFrontTimeDroplet[0].actualVolume / reachedNode.inletVolumetricSpeed);\r\n              }\r\n\r\n              reachedNode.outletVolumetricSpeed = reachedNode.inletVolumetricSpeed+reachedNode.connectedPumpSpeedAtPause;\r\n              smallestFrontTimeDroplet[0].frontVolumetricSpeed += reachedNode.connectedPumpSpeedAtPause;\r\n              //smallestFrontTimeDroplet[0].rearVolumetricSpeed = 0;\r\n              smallestFrontTimeDroplet[0].frontTimeToReachNextNode = smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode/smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n              smallestFrontTimeDroplet[0].frontNextNodeID = nextNode.node.id;\r\n              //smallestFrontTimeDroplet[0].rearNextNodeID = findFurthestNode(findOutletNode(graphData.nodes), graphData.nodes, graphData.links).id;\r\n              //smallestFrontTimeDroplet[0].pumpSpeedMultiplier = 1;\r\n              //smallestFrontTimeDroplet[0].pauseLevel = 0;\r\n              //smallestFrontTimeDroplet[0].frontVolumetricSpeedAtPause = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n              //smallestFrontTimeDroplet[0].rearVolumetricSpeedAtPause = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n              //smallestFrontTimeDroplet[0].stoppingDroplet = true;\r\n              event={\r\n                type: 'setPumpSpeed',\r\n                target: reachedNode.connectedPump.id,\r\n                time: newTimePassed,\r\n                value: reachedNode.connectedPumpSpeedAtPause \r\n              };\r\n              eventList.push(event);\r\n              //update newer droplets\r\n              dropletsNewer.forEach(droplet => {\r\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontTimeToReachNextNode -= smallestFrontTime;\r\n                droplet.rearTimeToReachNextNode -= smallestFrontTime;\r\n              });\r\n              //aktualizuje starsze krople\r\n              let accumulatedSpeed = reachedNode.connectedPumpSpeedAtPause;\r\n              dropletsOlder.reverse().forEach(droplet => {\r\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\r\n                droplet.rearVolumetricSpeed += accumulatedSpeed; \r\n                getPumpsBetweenPositions(droplet.frontVolumetricPosition,droplet.rearVolumetricPosition, graphData.nodes, graphData.links).forEach(pump => {\r\n                  const editedNode = orderedNodes.find(node => node.connectedPump.id === pump.id);\r\n                  //editedNode.pumpSpeedMultiplier = 1;\r\n                  const pumpBoost = editedNode.connectedPumpSpeedAtPause * accumulatedSpeed/editedNode.inletVolumetricSpeed;\r\n                  editedNode.connectedPumpSpeedAtPause += pumpBoost;\r\n                  editedNode.inletVolumetricSpeed += accumulatedSpeed;\r\n                  accumulatedSpeed += pumpBoost;\r\n                  editedNode.outletVolumetricSpeed += accumulatedSpeed;\r\n                  event={\r\n                    type: 'setPumpSpeed',\r\n                    target: pump.id,\r\n                    time: newTimePassed,\r\n                    value: editedNode.connectedPumpSpeedAtPause\r\n                  };\r\n                  eventList.push(event);\r\n                });\r\n                droplet.frontVolumetricSpeed += accumulatedSpeed;\r\n                droplet.frontTimeToReachNextNode = droplet.frontVolumetricDistanceToNextNode/droplet.frontVolumetricSpeed;\r\n                droplet.rearTimeToReachNextNode = droplet.rearVolumetricDistanceToNextNode/droplet.rearVolumetricSpeed;\r\n\r\n              });\r\n            }\r\n          }\r\n          else if (reachedNode.node.type === 'thermostat' || reachedNode.type === 'LED') {//przypadek gdy dochodzi do termostatu\r\n            console.log('reachedNode (thermostat, LED): ', reachedNode);\r\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\r\n            if (nextNode) {\r\n              const nextEdge = graphData.links.find(link => link.source === smallestFrontTimeDroplet[0].frontNextNodeID && link.target === nextNode.node.id);\r\n              //aktualizuje krople\r\n              currentBlockDroplets.forEach(droplet => {\r\n                droplet.frontTimeToReachNextNode -= smallestFrontTime;\r\n                droplet.rearTimeToReachNextNode -= smallestFrontTime;\r\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\r\n              });\r\n              smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\r\n              smallestFrontTimeDroplet[0].frontTimeToReachNextNode = smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode / smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n              smallestFrontTimeDroplet[0].frontNextNodeID = nextNode.node.id;\r\n            }\r\n          }\r\n          else if (reachedNode.node.type === 'outlet') { //jeśli ostatni node osiągnięty\r\n            console.log('reachedNode (outlet): ', reachedNode);\r\n            //typowe zaktualizowanie czasu do następnego noda dla reszty kropel i zestallowanie frontu\r\n            currentBlockDroplets.forEach(droplet => {\r\n              droplet.frontTimeToReachNextNode -= smallestFrontTime;\r\n              droplet.rearTimeToReachNextNode -= smallestFrontTime;\r\n              droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\r\n              droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\r\n              droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\r\n              droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\r\n            });\r\n            smallestFrontTimeDroplet[0].frontTimeToReachNextNode = Infinity;\r\n            smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = Infinity;\r\n            smallestFrontTimeDroplet[0].frontNextNodeID = null;\r\n          }\r\n          else if (reachedNode.node.type === 'detector' || reachedNode.node.type === 'USBSpectrometer' || reachedNode.node.type === 'MQTTSpectrometer') { //przypadek gdy dochodzi do detektora\r\n            console.log('reachedNode (detector): ', reachedNode);\r\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\r\n            if (nextNode) {\r\n              const nextEdge = graphData.links.find(link => link.source === smallestFrontTimeDroplet[0].frontNextNodeID && link.target === nextNode.node.id);\r\n              //aktualizuje krople\r\n              currentBlockDroplets.forEach(droplet => {\r\n                droplet.frontTimeToReachNextNode -= smallestFrontTime;\r\n                droplet.rearTimeToReachNextNode -= smallestFrontTime;\r\n                droplet.frontVolumetricDistanceToNextNode -= smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricDistanceToNextNode -= smallestFrontTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontVolumetricPosition += smallestFrontTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricPosition += smallestFrontTime * droplet.rearVolumetricSpeed;\r\n              });\r\n              smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\r\n              smallestFrontTimeDroplet[0].frontTimeToReachNextNode = smallestFrontTimeDroplet[0].frontVolumetricDistanceToNextNode / smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n              smallestFrontTimeDroplet[0].frontNextNodeID = nextNode.node.id;\r\n            }\r\n          }\r\n        }\r\n      } \r\n      \r\n      else {//przypadek gdzie tył jest przed przodem\r\n        console.log('Rear time is smaller than front time');\r\n        if (smallestRearTimeDroplet.length > 1) { //przypadek gdy dochodzi do noda wiele kropel\r\n          console.log(`Multiple droplets ends have reached the next node simultaneously`);\r\n          smallestRearTimeDroplet.forEach(droplet => {\r\n            // Perform some action for each droplet in smallestRearTimeDroplet\r\n          });\r\n        } \r\n        else { //przypadek gdy tył jednej kropelki dochodzi do noda\r\n          const reachedNode = orderedNodes.find(n => n.node.id === smallestRearTimeDroplet[0].rearNextNodeID);\r\n          const reachedNodeDistance = orderedNodes.find(node => node.node.id === reachedNode.node.id).distance;\r\n          \r\n          if (reachedNode.node.type === 'connector') { //przypadek gdy dochodzi do connectora\r\n            console.log('reachedNode is connector');\r\n\r\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\r\n            const nextEdge = graphData.links.find(link => link.source === smallestRearTimeDroplet[0].rearNextNodeID && link.target === nextNode.node.id);\r\n            const index = currentBlockDroplets.indexOf(smallestRearTimeDroplet[0]);\r\n            const dropletsOlder = currentBlockDroplets.slice(0, index);\r\n            const dropletsNewer = currentBlockDroplets.slice(index + 1);\r\n            if (smallestRearTimeDroplet[0].stoppingDroplet === true){ //wznawia jeśli była zatrzymana\r\n              //aktualizuje starsze krople\r\n              dropletsOlder.forEach(droplet => {\r\n                droplet.frontTimeToReachNextNode -= smallestRearTime;\r\n                droplet.rearTimeToReachNextNode -= smallestRearTime;\r\n                droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\r\n              });\r\n\r\n              //aktualizuje nowsze krople\r\n              dropletsNewer.forEach(droplet => {\r\n                if (droplet.pauseLevel === 1){//\r\n                  droplet.pauseLevel = 0;\r\n                  droplet.frontVolumetricSpeed = droplet.frontVolumetricSpeedAtPause;\r\n                  droplet.rearVolumetricSpeed = droplet.rearVolumetricSpeedAtPause;\r\n                  getPumpsBetweenPositions(droplet.frontVolumetricPosition,droplet.rearVolumetricPosition, graphData.nodes, graphData.links).forEach(pump => {\r\n                    \r\n                    event={\r\n                      type: 'setPumpSpeed',\r\n                      target: pump.id,\r\n                      time: newTimePassed,\r\n                      value: orderedNodes.find(node => node.node.id === pump.id).connectedPumpSpeedAtPause\r\n                    };\r\n                    eventList.push(event);\r\n                  });\r\n                }\r\n                else {\r\n                  droplet.pauseLevel -= 1;\r\n                }\r\n                droplet.frontTimeToReachNextNode -= smallestRearTime;\r\n                droplet.rearTimeToReachNextNode -= smallestRearTime;\r\n              });\r\n\r\n              reachedNode.connectedPumpRatio = 0; \r\n              //reachedNode.inletVolumetricSpeed = 0;\r\n              //smallestRearTimeDroplet[0].frontVolumetricSpeed = reachedNode.outletVolumetricSpeed;\r\n              smallestRearTimeDroplet[0].rearVolumetricSpeed = smallestRearTimeDroplet[0].rearVolumetricSpeedAtPause;\r\n              smallestRearTimeDroplet[0].frontVolumetricPosition += smallestRearTimeDroplet[0].frontVolumetricSpeed*smallestRearTime;\r\n              smallestRearTimeDroplet[0].rearVolumetricPosition = reachedNode.node.volumetricPosition;\r\n              smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode -= smallestRearTimeDroplet[0].frontVolumetricSpeed*smallestRearTime;\r\n              smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge); \r\n              smallestRearTimeDroplet[0].frontTimeToReachNextNode = smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode/smallestRearTimeDroplet[0].frontVolumetricSpeed;\r\n              smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode/smallestRearTimeDroplet[0].rearVolumetricSpeed;\r\n              //smallestRearTimeDroplet[0].frontNextNodeID = nextNode.id;\r\n              smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\r\n              //smallestRearTimeDroplet[0].pumpSpeedMultiplier = 1;\r\n              //smallestRearTimeDroplet[0].pauseLevel = 0;\r\n              smallestRearTimeDroplet[0].frontVolumetricSpeedAtPause = smallestRearTimeDroplet[0].frontVolumetricSpeed;\r\n              smallestRearTimeDroplet[0].rearVolumetricSpeedAtPause = smallestRearTimeDroplet[0].rearVolumetricSpeed;\r\n              smallestRearTimeDroplet[0].stoppingDroplet = false;\r\n              smallestRearTimeDroplet[0].initialPumping = false;\r\n\r\n              reachedNode.connectedPumpRatio = 0;\r\n              event = {\r\n                type: 'setPumpSpeed',\r\n                target: reachedNode.connectedPump.id,\r\n                time: newTimePassed,\r\n                value: 0\r\n              };\r\n              eventList.push(event);\r\n              event = {\r\n                type: 'setPumpSpeed',\r\n                target: selectedCarrierPumps[0],\r\n                time: newTimePassed,\r\n                value: commonVolumetricSpeed\r\n              };\r\n              eventList.push(event);\r\n\r\n            }\r\n            else {\r\n              console.log('it is not stopper');\r\n              if (reachedNode.connectedPump.id !== null){\r\n                \r\n                const speedDifference = reachedNode.outletVolumetricSpeed - reachedNode.inletVolumetricSpeed;\r\n                //reachedNode.inletVolumetricSpeed = smallestFrontTimeDroplet[0].frontVolumetricSpeed;\r\n                reachedNode.outletVolumetricSpeed = reachedNode.inletVolumetricSpeed;\r\n                reachedNode.connectedPumpRatio = 0;\r\n                reachedNode.connectedPumpSpeedAtPause = 0;\r\n                smallestRearTimeDroplet[0].frontVolumetricPosition += smallestRearTime * smallestRearTimeDroplet[0].frontVolumetricSpeed;\r\n                smallestRearTimeDroplet[0].rearVolumetricPosition = reachedNode.node.volumetricPosition;\r\n                smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode -= smallestRearTime * smallestRearTimeDroplet[0].frontVolumetricSpeed;\r\n                smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge); \r\n                //smallestRearTimeDroplet[0].frontNextNodeID = nextNode.id;\r\n                smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\r\n                //smallestRearTimeDroplet[0].pumpSpeedMultiplier = 1;\r\n                //smallestRearTimeDroplet[0].pauseLevel = 0; \r\n                //smallestRearTimeDroplet[0].stoppingDroplet = true;\r\n                smallestRearTimeDroplet[0].frontVolumetricSpeed = smallestRearTimeDroplet[0].frontVolumetricSpeed-speedDifference;\r\n                //smallestRearTimeDroplet[0].rearVolumetricSpeed = 0;\r\n                smallestRearTimeDroplet[0].frontVolumetricSpeedAtPause = smallestRearTimeDroplet[0].frontVolumetricSpeed;\r\n                //smallestRearTimeDroplet[0].rearVolumetricSpeedAtPause = smallestRearTimeDroplet[0].rearVolumetricSpeed;\r\n                smallestRearTimeDroplet[0].frontTimeToReachNextNode = smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].frontVolumetricSpeed;\r\n                smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].rearVolumetricSpeed;\r\n                event={\r\n                  type: 'setPumpSpeed',\r\n                  target: reachedNode.connectedPump.id,\r\n                  time: newTimePassed,\r\n                  value: reachedNode.connectedPumpSpeedAtPause \r\n                };\r\n                eventList.push(event);\r\n                //updte newer droplets\r\n                dropletsNewer.forEach(droplet => {\r\n                  droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\r\n                  droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\r\n                  droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\r\n                  droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\r\n                  droplet.frontTimeToReachNextNode -= smallestRearTime;\r\n                  droplet.rearTimeToReachNextNode -= smallestRearTime;\r\n                });\r\n                //aktualizuje starsze krople\r\n                let accumulatedSpeedDecrease = speedDifference;\r\n                dropletsOlder.reverse().forEach(droplet => {\r\n                  droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\r\n                  droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\r\n                  droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\r\n                  droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\r\n                  droplet.rearVolumetricSpeed -= accumulatedSpeedDecrease;\r\n                  getPumpsBetweenPositions(droplet.frontVolumetricPosition,droplet.rearVolumetricPosition, graphData.nodes, graphData.links).forEach(pump => {\r\n                    const editedNode = orderedNodes.find(node => node.connectedPump.id === pump.id);\r\n                    const pumpBreak = editedNode.connectedPumpSpeedAtPause * accumulatedSpeedDecrease/editedNode.inletVolumetricSpeed;\r\n                    editedNode.connectedPumpSpeedAtPause -= pumpBreak;\r\n                    editedNode.inletVolumetricSpeed -= accumulatedSpeedDecrease;\r\n                    accumulatedSpeedDecrease += pumpBreak;\r\n                    editedNode.outletVolumetricSpeed -= accumulatedSpeedDecrease;\r\n                    event={\r\n                      type: 'setPumpSpeed',\r\n                      target: pump.id,\r\n                      time: newTimePassed,\r\n                      value: editedNode.connectedPumpSpeedAtPause\r\n                    };\r\n                    eventList.push(event);\r\n                  });\r\n                  droplet.frontVolumetricSpeed -= accumulatedSpeedDecrease;\r\n                  droplet.frontTimeToReachNextNode = droplet.frontVolumetricDistanceToNextNode/droplet.frontVolumetricSpeed;\r\n                  droplet.rearTimeToReachNextNode = droplet.rearVolumetricDistanceToNextNode/droplet.rearVolumetricSpeed;\r\n  \r\n                });\r\n              }\r\n            }\r\n\r\n          }\r\n          else if (reachedNode.node.type === 'thermostat' || reachedNode.node.type === 'LED') {//przypadek gdy dochodzi do termostatu\r\n            console.log('reachedNode thermostat: ', reachedNode);\r\n            \r\n            const isFarthestThermostatOrLED = orderedNodes.filter(node => node.node.type === 'thermostat' || node.node.type === 'LED').every(node => node.distance <= reachedNodeDistance);\r\n            \r\n            // This line checks if the smallestRearTimeDroplet is the last droplet in the currentBlockDroplets array.\r\n            if (isFarthestThermostatOrLED && currentBlockDroplets.length === currentBlockDroplets.indexOf(smallestRearTimeDroplet[0])+1) {\r\n              console.log('This is the farthest thermostat or LED node. Also, last droplet just passed through it.');\r\n              const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\r\n              const waitTime = smallestRearTimeDroplet[0].parameters.find(param => param.nodeId === reachedNode.node.id && param.name === 'time')?.value || 0;\r\n              if (nextNode) {\r\n                const nextEdge = graphData.links.find(link => link.source === smallestRearTimeDroplet[0].rearNextNodeID && link.target === nextNode.node.id);\r\n                smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\r\n                smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode/smallestRearTimeDroplet[0].rearVolumetricSpeed + smallestRearTime;\r\n                smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\r\n                //aktualizuje resztę kropli\r\n                currentBlockDroplets.forEach(droplet => {\r\n                  droplet.frontTimeToReachNextNode += waitTime - smallestRearTime;\r\n                  droplet.rearTimeToReachNextNode += waitTime - smallestRearTime;\r\n                  droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\r\n                  droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\r\n                  droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed-waitTime * droplet.frontVolumetricSpeed;//to jest zrobione na razie aby czas się zgadzał\r\n                  droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed-waitTime * droplet.rearVolumetricSpeed;\r\n                });\r\n\r\n                let carrierPumpEvent = {\r\n                  type: 'setPumpSpeed',\r\n                  target: selectedCarrierPumps[0], // Assuming 'carrierPumpId' is the ID of the carrier pump\r\n                  time: newTimePassed,\r\n                  value: 0\r\n                };\r\n                eventList.push(carrierPumpEvent);\r\n                carrierPumpEvent = {\r\n                  type: 'setPumpSpeed',\r\n                  target: selectedCarrierPumps[0], // Assuming 'carrierPumpId' is the ID of the carrier pump\r\n                  time: newTimePassed+waitTime,\r\n                  value: commonVolumetricSpeed\r\n                };\r\n                eventList.push(carrierPumpEvent);\r\n              }\r\n            }\r\n            else { //droplet wasnt the last one\r\n              console.log('smallestRearTimeDroplet is not the last droplet in the currentBlockDroplets array');\r\n              const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\r\n              if (nextNode) {\r\n                const nextEdge = graphData.links.find(link => link.source === smallestRearTimeDroplet[0].rearNextNodeID && link.target === nextNode.node.id);\r\n                //aktualizuje krople\r\n                currentBlockDroplets.forEach(droplet => {\r\n                  droplet.frontTimeToReachNextNode -= smallestRearTime;\r\n                  droplet.rearTimeToReachNextNode -= smallestRearTime;\r\n                  droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\r\n                  droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\r\n                  droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\r\n                  droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\r\n                });\r\n                smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\r\n                smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].rearVolumetricSpeed;\r\n                smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\r\n              }\r\n            }\r\n          }\r\n          else if (reachedNode.node.type === 'outlet') { //jeśli ostatni node osiągnięty\r\n            //typowe zaktualizowanie czasu do następnego noda dla reszty kropel i zestallowanie reara\r\n            //aktualizuje resztę kropli\r\n            currentBlockDroplets.forEach(droplet => {\r\n              droplet.frontTimeToReachNextNode -= smallestRearTime;\r\n              droplet.rearTimeToReachNextNode -= smallestRearTime;\r\n              droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\r\n              droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\r\n              droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\r\n              droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\r\n            });\r\n            smallestRearTimeDroplet[0].frontTimeToReachNextNode = Infinity;\r\n            smallestRearTimeDroplet[0].frontVolumetricDistanceToNextNode = Infinity;\r\n            smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = Infinity;\r\n            smallestRearTimeDroplet[0].rearNextNodeID = null;\r\n            smallestRearTimeDroplet[0].rearTimeToReachNextNode = Infinity;\r\n          }\r\n          else if (reachedNode.node.type === 'detector' || reachedNode.node.type === 'USBSpectrometer' || reachedNode.node.type === 'MQTTSpectrometer') { //przypadek gdy dochodzi do detektora\r\n            console.log('reachedNode (detector): ', reachedNode);\r\n            const nextNode = orderedNodes.find(node => node.distance === reachedNodeDistance - 1 && node.node.type !== 'pump');\r\n            if (nextNode) {\r\n              const nextEdge = graphData.links.find(link => link.source === smallestRearTimeDroplet[0].rearNextNodeID && link.target === nextNode.node.id);\r\n              //aktualizuje krople\r\n              currentBlockDroplets.forEach(droplet => {\r\n                droplet.frontTimeToReachNextNode -= smallestRearTime;\r\n                droplet.rearTimeToReachNextNode -= smallestRearTime;\r\n                droplet.frontVolumetricDistanceToNextNode -= smallestRearTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricDistanceToNextNode -= smallestRearTime * droplet.rearVolumetricSpeed;\r\n                droplet.frontVolumetricPosition += smallestRearTime * droplet.frontVolumetricSpeed;\r\n                droplet.rearVolumetricPosition += smallestRearTime * droplet.rearVolumetricSpeed;\r\n              });\r\n              smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode = calculateEdgeVolume(nextEdge);\r\n              smallestRearTimeDroplet[0].rearTimeToReachNextNode = smallestRearTimeDroplet[0].rearVolumetricDistanceToNextNode / smallestRearTimeDroplet[0].rearVolumetricSpeed;\r\n              smallestRearTimeDroplet[0].rearNextNodeID = nextNode.node.id;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      timePassed = newTimePassed;\r\n      // Update last droplet rear position\r\n      lastDropletRearPosition = currentBlockDroplets[currentBlockDroplets.length - 1].rearVolumetricPosition;\r\n\r\n      //add code that preserves droplets positions and speeds for visualization\r\n      const dropletState = {\r\n        time: timePassed,\r\n        droplets: currentBlockDroplets.map(droplet => ({\r\n          id: droplet.id,\r\n          frontVolumetricPosition: droplet.frontVolumetricPosition,\r\n          rearVolumetricPosition: droplet.rearVolumetricPosition,\r\n          frontVolumetricSpeed: droplet.frontVolumetricSpeed,\r\n          rearVolumetricSpeed: droplet.rearVolumetricSpeed,\r\n          pumpSpeedMultiplier: droplet.pumpSpeedMultiplier,\r\n          frontTimeToReachNextNode: droplet.frontTimeToReachNextNode,\r\n          rearTimeToReachNextNode: droplet.rearTimeToReachNextNode,\r\n          frontVolumetricDistanceToNextNode: droplet.frontVolumetricDistanceToNextNode,\r\n          rearVolumetricDistanceToNextNode: droplet.rearVolumetricDistanceToNextNode,\r\n          volume: droplet.parameters.find(p => p.name === 'volume')?.value || 0,\r\n          frontNextNodeID: droplet.frontNextNodeID,\r\n          rearNextNodeID: droplet.rearNextNodeID\r\n        }))\r\n      };\r\n      setDropletHistory(prev => [...prev, dropletState]);\r\n\r\n      \r\n\r\n      //if (timePassed > 9999) {//here for testing, preventing infinite loop\r\n      //  lastDropletRearPosition = 88100;\r\n      //}\r\n\r\n    }\r\n    event = {//it is ok\r\n      type: 'setPumpSpeed',\r\n      target: selectedCarrierPumps[0],\r\n      time: timePassed,\r\n      value: 0\r\n    };\r\n    eventList.push(event);\r\n\r\n    eventList = cleanAndSortEventList(eventList);\r\n    console.log('dropletHistory in event generator: ', dropletHistory);\r\n    console.log('eventList: ', eventList.sort((a, b) => a.time - b.time));\r\n    setPumpEvents(extractPumpEvents(eventList));\r\n    return eventList;\r\n  }\r\n  // First useEffect to set initial graphData\r\n  useEffect(() => {\r\n    setDropletHistory([]);\r\n    if (nodes.length > 0 && edges.length > 0) {\r\n      const graphNodes = nodes.map(node => ({\r\n        id: node.id,\r\n        label: node.data.label,\r\n        type: node.data.type,\r\n        x: 0,\r\n        y: 0,\r\n        volumetricPosition: 0\r\n      }));\r\n\r\n      const graphLinks = edges.map(edge => ({\r\n        source: edge.source,\r\n        target: edge.target,\r\n        length: edge.data?.properties?.length || 100,\r\n        diameter: edge.data?.properties?.diameter || 1,\r\n      }));\r\n\r\n      setGraphData({ nodes: graphNodes, links: graphLinks });\r\n    }\r\n    \r\n  }, [nodes, edges]);\r\n\r\n  // Second useEffect to calculate nodes positions and set up simulation data\r\n  useEffect(() => {\r\n    if (!graphData.nodes.length || !graphData.links.length || !droplets.length) {\r\n      console.log('Missing required data for simulation setup:', {\r\n        nodesLength: graphData.nodes.length,\r\n        linksLength: graphData.links.length,\r\n        dropletsLength: droplets.length\r\n      });\r\n      return;\r\n    }\r\n\r\n    const graphNodes = [...graphData.nodes];\r\n    \r\n    // Find outlet node first\r\n    const outletNode = findOutletNode(graphData.nodes);\r\n    if (!outletNode) {\r\n      console.error('No outlet node found. Cannot set up simulation.');\r\n      return;\r\n    }\r\n\r\n    // Get ordered nodes from outlet\r\n    const orderedNodes = orderNodesByDistance(outletNode, graphData.nodes, graphData.links);\r\n    \r\n    // Separate nodes into main line and secondary line\r\n    const mainLineNodes = orderedNodes\r\n      .filter(({node}) => \r\n        setOfMainLineNodes.includes(node.type))\r\n      .reverse();\r\n      \r\n    const secondaryLineNodes = orderedNodes\r\n      .filter(({node}) => setOfSecondaryLineNodes.includes(node.type))\r\n      .sort((a, b) => b.distance - a.distance);\r\n\r\n    // Position settings\r\n    const mainLineY = 300;\r\n    const secondaryLineY = 150;\r\n    const pumpSpacing = 100; // Increased horizontal spacing between pumps\r\n    let currentX = 100;\r\n\r\n    // Position main line nodes\r\n    let currentVolumetricPosition = 0;\r\n    mainLineNodes.forEach(({node}, index) => {\r\n      const graphNode = graphNodes.find(n => n.id === node.id);\r\n      if (!graphNode) return;\r\n\r\n      graphNode.x = currentX;\r\n      graphNode.y = mainLineY;\r\n      graphNode.volumetricPosition = currentVolumetricPosition;\r\n      \r\n      if (index < mainLineNodes.length - 1) {\r\n        const nextNode = mainLineNodes[index + 1];\r\n        const edge = graphData.links.find(e => \r\n          (e.source === graphNode.id && e.target === nextNode.node.id) ||\r\n          (e.target === graphNode.id && e.source === nextNode.node.id)\r\n        );\r\n        \r\n        if (edge && edge.length) {\r\n          currentX += edge.length * 2;\r\n          // Use existing calculateEdgeVolume function\r\n          const edgeVolume = calculateEdgeVolume(edge);\r\n          currentVolumetricPosition += edgeVolume;\r\n        } else {\r\n          currentX += 200;\r\n          currentVolumetricPosition += 150;\r\n        }\r\n      }\r\n    });\r\n\r\n    // Group secondary nodes by distance\r\n    const nodesByDistance = {};\r\n    secondaryLineNodes.forEach(({node, distance}) => {\r\n      if (!nodesByDistance[distance]) {\r\n        nodesByDistance[distance] = [];\r\n      }\r\n      nodesByDistance[distance].push(node);\r\n    });\r\n\r\n    // Position secondary nodes based on their connected main line nodes\r\n    const pumpOffset = 50; // Add this constant for pump spacing\r\n    Object.entries(nodesByDistance).forEach(([distance, nodes]) => {\r\n      nodes.forEach((node, index) => {\r\n        const graphNode = graphNodes.find(n => n.id === node.id);\r\n        if (!graphNode) return;\r\n\r\n        // Find connected main line node through edges\r\n        const connectedEdge = edges.find(e => \r\n          e.source === node.id || e.target === node.id\r\n        );\r\n        \r\n        if (connectedEdge) {\r\n          const connectedNodeId = connectedEdge.source === node.id ? connectedEdge.target : connectedEdge.source;\r\n          const connectedMainNode = graphNodes.find(n => n.id === connectedNodeId);\r\n          \r\n          if (connectedMainNode) {\r\n            // Position pump above its connected main line node with offset if needed\r\n            graphNode.x = connectedMainNode.x + (index * pumpOffset) - ((nodes.length - 1) * pumpOffset / 2);\r\n            graphNode.y = secondaryLineY;\r\n          }\r\n        }\r\n      });\r\n    });\r\n\r\n    setGraphData(prev => ({ ...prev, nodes: graphNodes }));\r\n    \r\n    // Only calculate volumes and blocks if not already done\r\n    if (currentBlockDroplets.length === 0) {\r\n      console.log('Calculating thermostat volumes and blocks for droplets:', droplets.length);\r\n      const thermoVol = calculateVolumesBetweenThermostats(graphData);\r\n      \r\n      // Create deep copy of droplets to avoid mutation issues\r\n      const dropletsCopy = JSON.parse(JSON.stringify(droplets));\r\n      const blocks = divideDropletsIntoBlocks(dropletsCopy, thermoVol);\r\n      \r\n      if (blocks.length > 0) {\r\n        setCurrentBlockDroplets(blocks[0].droplets);\r\n        // Generate event list only once when initializing\r\n        const eventList = generateEventList(blocks);\r\n        const eventListForDevices = recalculateEventListForDevices(eventList);\r\n      }\r\n    }\r\n    \r\n    // Important: the dependency array includes currentBlockDroplets.length to prevent infinite recalculations\r\n  }, [graphData.nodes.length, graphData.links.length, droplets, edges, currentBlockDroplets.length]);\r\n\r\n  const startSimulation = useCallback(() => {\r\n    setIsSimulationRunning(true);\r\n    lastFrameTimeRef.current = null; // Reset the last frame time\r\n  }, []);\r\n\r\n  const stopSimulation = useCallback(() => {\r\n    setIsSimulationRunning(false);\r\n    if (animationFrameRef.current) {\r\n      cancelAnimationFrame(animationFrameRef.current);\r\n      animationFrameRef.current = null;\r\n    }\r\n  }, []);\r\n\r\n  const restartSimulation = useCallback(() => {\r\n    stopSimulation();\r\n    setKey(prevKey => prevKey + 1);\r\n    setCurrentTime(0);\r\n    startSimulation();\r\n  }, [stopSimulation, startSimulation]);\r\n\r\n\r\n  const getNodeColor = (node) => {\r\n    switch (node.type) {\r\n      case 'pump': return '#4CAF50';\r\n      case 'connector': return '#2196F3';\r\n      case 'outlet': return '#F44336';\r\n      default: return '#FFA000'; // Default color for unknown types\r\n    }\r\n  };\r\n\r\n  // Update volumetricToXPosition function\r\n  const volumetricToXPosition = useCallback((volumetricPosition) => {\r\n    const outletNode = findOutletNode(graphData.nodes);\r\n    const furthestNode = findFurthestNode(outletNode, graphData.nodes, graphData.links);\r\n    \r\n    if (!outletNode || !furthestNode) return 0;\r\n\r\n    const totalVolume = getVolumeBetweenNodes(furthestNode.id, outletNode.id, graphData.nodes, graphData.links);\r\n    const outletX = graphData.nodes.find(n => n.id === outletNode.id)?.x || 0;\r\n    const furthestX = graphData.nodes.find(n => n.id === furthestNode.id)?.x || 0;\r\n    \r\n    // Handle edge cases\r\n    if (!totalVolume || totalVolume === 0 || isNaN(totalVolume)) {\r\n      console.warn('Total volume is invalid:', totalVolume);\r\n      return furthestX;\r\n    }\r\n\r\n    if (volumetricPosition === undefined || volumetricPosition === null || isNaN(volumetricPosition)) {\r\n      console.warn('Volumetric position is invalid:', volumetricPosition);\r\n      return furthestX;\r\n    }\r\n\r\n    // Clamp the position to valid range\r\n    const clampedPosition = Math.max(-totalVolume, Math.min(totalVolume, volumetricPosition));\r\n    \r\n    // Apply scaling factor to the position calculation\r\n    const scaledX = furthestX + ((clampedPosition / totalVolume) * (outletX - furthestX));\r\n    \r\n    // Ensure the returned value is a valid number\r\n    if (!isFinite(scaledX) || isNaN(scaledX)) {\r\n      console.warn('Invalid scaled position calculated:', {\r\n        scaledX,\r\n        clampedPosition,\r\n        totalVolume,\r\n        outletX,\r\n        furthestX\r\n      });\r\n      return furthestX;\r\n    }\r\n    \r\n    return scaledX;\r\n  }, [graphData.nodes]);    \r\n\r\n  // Update the updateDropletPositions function\r\n  const updateDropletPositions = useCallback((timestamp) => {\r\n    if (!isSimulationRunning || dropletHistory.length === 0) return;\r\n\r\n    if (!lastFrameTimeRef.current) {\r\n      lastFrameTimeRef.current = timestamp;\r\n      animationFrameRef.current = requestAnimationFrame(updateDropletPositions);\r\n      return;\r\n    }\r\n\r\n    const deltaTime = (timestamp - lastFrameTimeRef.current) / 1000; // Convert to seconds\r\n    const simulationDeltaTime = deltaTime * timeScale;\r\n    \r\n    setCurrentTime(prevTime => {\r\n      const newTime = prevTime + simulationDeltaTime;\r\n      \r\n      // Get the time range of our history\r\n      const lastHistoryTime = dropletHistory[dropletHistory.length - 1].time;\r\n      \r\n      // If we've reached the end, loop back to start\r\n      if (newTime >= lastHistoryTime) {\r\n        setCurrentTime(0);\r\n        return 0;\r\n      }\r\n\r\n      // Find the appropriate states to interpolate between\r\n      const currentState = interpolateDropletState(newTime);\r\n      // Update droplet visualization\r\n      const updatedDroplets = currentState.map(droplet => {\r\n        const frontX = volumetricToXPosition(droplet.frontVolumetricPosition);\r\n        const rearX = volumetricToXPosition(droplet.rearVolumetricPosition);\r\n\r\n        if (isNaN(frontX) || isNaN(rearX)) {\r\n          console.warn('Invalid droplet position calculated:', {\r\n            dropletId: droplet.id,\r\n            frontPosition: droplet.frontVolumetricPosition,\r\n            rearPosition: droplet.rearVolumetricPosition,\r\n            frontX,\r\n            rearX\r\n          });\r\n          return null;\r\n        }\r\n\r\n        return {\r\n          id: droplet.id,\r\n          frontX,\r\n          rearX,\r\n          y: 300,\r\n          volume: droplet.frontVolumetricPosition-droplet.rearVolumetricPosition,\r\n          speed: droplet.frontVolumetricSpeed\r\n        };\r\n      }).filter(Boolean);\r\n\r\n      setSimulationDroplets(updatedDroplets);\r\n      return newTime;\r\n    });\r\n\r\n    lastFrameTimeRef.current = timestamp;\r\n    animationFrameRef.current = requestAnimationFrame(updateDropletPositions);\r\n  }, [isSimulationRunning, timeScale, volumetricToXPosition, dropletHistory]);\r\n\r\n  // Add animation effect\r\n  useEffect(() => {\r\n    if (isSimulationRunning) {\r\n      lastFrameTimeRef.current = null;\r\n      animationFrameRef.current = requestAnimationFrame(updateDropletPositions);\r\n    }\r\n    return () => {\r\n      if (animationFrameRef.current) {\r\n        cancelAnimationFrame(animationFrameRef.current);\r\n      }\r\n    };\r\n  }, [isSimulationRunning, updateDropletPositions]);\r\n\r\n  // Add this helper function for interpolation\r\n  const interpolateDropletState = (time) => {\r\n    if (!dropletHistory.length) return [];\r\n    \r\n    // Find the two closest states\r\n    const index = dropletHistory.findIndex(state => state.time > time);\r\n    if (index === -1) return dropletHistory[dropletHistory.length - 1].droplets;\r\n    if (index === 0) return dropletHistory[0].droplets;\r\n    \r\n    const beforeState = dropletHistory[index - 1];\r\n    const afterState = dropletHistory[index];\r\n    const fraction = (time - beforeState.time) / (afterState.time - beforeState.time);\r\n    \r\n    return beforeState.droplets.map(beforeDroplet => {\r\n      const afterDroplet = afterState.droplets.find(d => d.id === beforeDroplet.id);\r\n      if (!afterDroplet) return beforeDroplet;\r\n      \r\n      return {\r\n        ...beforeDroplet,\r\n        frontVolumetricPosition: beforeDroplet.frontVolumetricPosition + \r\n          (afterDroplet.frontVolumetricPosition - beforeDroplet.frontVolumetricPosition) * fraction,\r\n        rearVolumetricPosition: beforeDroplet.rearVolumetricPosition + \r\n          (afterDroplet.rearVolumetricPosition - beforeDroplet.rearVolumetricPosition) * fraction,\r\n      };\r\n    });\r\n  };\r\n\r\n  // Add navigation functions\r\n  const jumpToTimepoint = useCallback((index) => {\r\n    if (index >= 0 && index < dropletHistory.length) {\r\n      setCurrentTimepoint(index);\r\n      setCurrentTime(dropletHistory[index].time);\r\n    }\r\n  }, [dropletHistory]);\r\n\r\n  const nextTimepoint = useCallback(() => {\r\n    jumpToTimepoint(currentTimepoint + 1);\r\n  }, [currentTimepoint, jumpToTimepoint]);\r\n\r\n  const previousTimepoint = useCallback(() => {\r\n    jumpToTimepoint(currentTimepoint - 1);\r\n  }, [currentTimepoint, jumpToTimepoint]);\r\n\r\n\r\n\r\n  const handleNodeClick = (node) => {\r\n    console.log('Node clicked:', node);\r\n    console.log('Node type:', node.type);\r\n    console.log('Node data type:', node.data?.type);\r\n    \r\n    // Check both node.type and node.data.type\r\n    const nodeType = node.type || node.data?.type;\r\n    console.log('Determined node type:', nodeType);\r\n    \r\n    if (nodeType === 'pump' || nodeType === 'USBSpectrometer' || nodeType === 'MQTTSpectrometer') {\r\n      setSelectedNode(node);\r\n      console.log('Selected node set:', node.id, nodeType);\r\n    }\r\n  };\r\n\r\n  const handleNodeAction = (action) => {\r\n    console.log('Node action:', action);\r\n    // Here you would implement the actual device communication\r\n    // based on the action type and parameters\r\n  };\r\n\r\n  const togglePumpSpeeds = () => {\r\n    setDisplayPumpSpeeds(!displayPumpSpeeds);\r\n  };\r\n\r\n  // Toggle functions for each display option\r\n  const toggleNodeIds = () => {\r\n    setDisplayNodeIds(!displayNodeIds);\r\n  };\r\n  \r\n  const toggleDropletInfo = () => {\r\n    setDisplayDropletInfo(!displayDropletInfo);\r\n  };\r\n  \r\n  const toggleDropletGaps = () => {\r\n    setDisplayDropletGaps(!displayDropletGaps);\r\n  };\r\n  \r\n  const toggleEdgeLabels = () => {\r\n    setDisplayEdgeLabels(!displayEdgeLabels);\r\n  };\r\n  \r\n  const toggleDisplayMenu = () => {\r\n    setDisplayMenuOpen(!isDisplayMenuOpen);\r\n  };\r\n  \r\n  const toggleTimelineDropletInfo = () => {\r\n    setDisplayTimelineDropletInfo(!displayTimelineDropletInfo);\r\n  };\r\n  \r\n  // Close menu when clicking outside\r\n  useEffect(() => {\r\n    const handleClickOutside = (event) => {\r\n      if (displayMenuRef.current && !displayMenuRef.current.contains(event.target)) {\r\n        setDisplayMenuOpen(false);\r\n      }\r\n    };\r\n    \r\n    document.addEventListener('mousedown', handleClickOutside);\r\n    return () => {\r\n      document.removeEventListener('mousedown', handleClickOutside);\r\n    };\r\n  }, []);\r\n\r\n  // Function to toggle pump panel visibility\r\n  const togglePumpPanel = (pumpId) => {\r\n    setVisiblePumpPanel((prev) => (prev === pumpId ? null : pumpId));\r\n  };\r\n\r\n  // Add styles for the display menu\r\n  const styles = {\r\n    container: {\r\n      ...backgroundVariants.mainBackground,\r\n      padding: '20px',\r\n      minHeight: '100vh'\r\n    },\r\n    dropletInfo: {\r\n      padding: '8px',\r\n      borderRadius: '4px',\r\n      fontSize: '12px',\r\n      ...backgroundVariants.panelBackground,\r\n      color: '#fff',\r\n      minWidth: '150px'\r\n    },\r\n    timelineContainer: {\r\n      display: 'flex',\r\n      flexDirection: 'column',\r\n      gap: '10px',\r\n      marginBottom: '20px'\r\n    },\r\n    timeInput: {\r\n      width: '100px',\r\n      ...backgroundVariants.inputBackground,\r\n      padding: '5px',\r\n      borderRadius: '4px',\r\n      marginLeft: '8px'\r\n    },\r\n    buttonGroup: {\r\n      display: 'flex',\r\n      gap: '10px',\r\n      marginTop: '20px',\r\n      marginBottom: '20px'\r\n    },\r\n    timelineControls: {\r\n      display: 'flex',\r\n      flexDirection: 'column',\r\n      gap: '15px',\r\n      marginBottom: '20px',\r\n      ...backgroundVariants.panelBackground,\r\n      padding: '15px',\r\n      borderRadius: '4px'\r\n    },\r\n    timeControls: {\r\n      display: 'flex',\r\n      flexDirection: 'column',\r\n      gap: '15px'\r\n    },\r\n    sliderContainer: {\r\n      display: 'flex',\r\n      gap: '10px',\r\n      alignItems: 'center',\r\n      borderBottom: '1px solid rgba(255,255,255,0.1)',\r\n      paddingBottom: '15px'\r\n    },\r\n    timeStepButtons: {\r\n      display: 'flex',\r\n      gap: '5px',\r\n      alignItems: 'center',\r\n      justifyContent: 'flex-start'\r\n    },\r\n    timeScaleContainer: {\r\n      display: 'flex',\r\n      alignItems: 'center',\r\n      gap: '15px',\r\n      justifyContent: 'flex-start',\r\n      borderTop: '1px solid rgba(255,255,255,0.1)',\r\n      paddingTop: '15px'\r\n    },\r\n    svgContainer: {\r\n      background: backgroundVariants.panelBackground.background,\r\n      borderRadius: '4px',\r\n      padding: '10px'\r\n    },\r\n    navigationButtons: {\r\n      display: 'flex',\r\n      justifyContent: 'space-between',\r\n      marginBottom: '20px'\r\n    },\r\n    timeSlider: {\r\n      width: '33%',\r\n      ...backgroundVariants.inputBackground,\r\n      height: '20px',\r\n      borderRadius: '10px',\r\n      WebkitAppearance: 'none',\r\n      appearance: 'none',\r\n      background: backgroundVariants.inputBackground.background,\r\n      outline: 'none',\r\n      opacity: '0.7',\r\n      transition: 'opacity .2s',\r\n      '&:hover': {\r\n        opacity: '1'\r\n      },\r\n      '&::-webkit-slider-thumb': {\r\n        WebkitAppearance: 'none',\r\n        appearance: 'none',\r\n        width: '20px',\r\n        height: '20px',\r\n        background: '#4CAF50',\r\n        cursor: 'pointer',\r\n        borderRadius: '50%'\r\n      },\r\n      '&::-moz-range-thumb': {\r\n        width: '20px',\r\n        height: '20px',\r\n        background: '#4CAF50',\r\n        cursor: 'pointer',\r\n        borderRadius: '50%'\r\n      }\r\n    },\r\n    // Add styles for display menu\r\n    displayMenuButton: {\r\n      ...buttonVariants.infoButton,\r\n      position: 'relative'\r\n    },\r\n    displayMenu: {\r\n      position: 'absolute',\r\n      top: '100%',\r\n      right: 0,\r\n      backgroundColor: '#333',\r\n      border: '1px solid #555',\r\n      borderRadius: '4px',\r\n      padding: '8px 0',\r\n      zIndex: 1000,\r\n      width: '220px',\r\n      boxShadow: '0 2px 10px rgba(0, 0, 0, 0.3)'\r\n    },\r\n    menuItem: {\r\n      padding: '8px 16px',\r\n      cursor: 'pointer',\r\n      display: 'flex',\r\n      alignItems: 'center',\r\n      justifyContent: 'space-between',\r\n      color: 'white',\r\n      transition: 'background-color 0.2s',\r\n      '&:hover': {\r\n        backgroundColor: '#444'\r\n      }\r\n    },\r\n    checkmark: {\r\n      color: '#4CAF50',\r\n      fontWeight: 'bold'\r\n    }\r\n  };\r\n\r\n  const sliderStyle = {\r\n    width: '100%',\r\n    height: '10px',\r\n    borderRadius: '5px', \r\n    background: '#333',\r\n    outline: 'none',\r\n    opacity: '0.7',\r\n    transition: 'opacity .2s'\r\n    // Remove all pseudo-element styles that were here\r\n  };\r\n\r\n  return (\r\n    <div style={styles.container}>\r\n      <div style={styles.timelineControls}>\r\n        <div style={styles.timeControls}>\r\n          <div style={styles.sliderContainer}>\r\n            <input\r\n              type=\"range\"\r\n              min={0}\r\n              max={Math.max(0, dropletHistory.length - 1)}\r\n              value={currentTimepoint}\r\n              onChange={(e) => jumpToTimepoint(Number(e.target.value))}\r\n              disabled={isSimulationRunning}\r\n              style={styles.timeSlider}\r\n              className=\"time-slider\" // Add this className\r\n            />\r\n            {displayTimelineDropletInfo && (\r\n              <div style={{ display: 'flex', gap: '10px', flexWrap: 'wrap' }}>\r\n                {dropletHistory.length > 0 && dropletHistory[currentTimepoint]?.droplets.map((droplet, index) => (\r\n                  <div key={droplet.id} style={styles.dropletInfo}>\r\n                    <div>Droplet {index + 1}:</div>\r\n                    {droplet.frontNextNodeID && (\r\n                      <div>Front → {graphData.nodes.find(n => n.id === droplet.frontNextNodeID)?.label || droplet.frontNextNodeID}</div>\r\n                    )}\r\n                    {droplet.rearNextNodeID && (\r\n                      <div>Rear → {graphData.nodes.find(n => n.id === droplet.rearNextNodeID)?.label || droplet.rearNextNodeID}</div>\r\n                    )}\r\n                  </div>\r\n                ))}\r\n              </div>\r\n            )}\r\n          </div>\r\n\r\n          <div style={styles.timeStepButtons}>\r\n            <button\r\n              onClick={() => jumpToTimepoint(0)}\r\n              disabled={currentTimepoint === 0 || isSimulationRunning}\r\n              style={{ ...buttonVariants.secondaryButton, padding: '4px 8px' }}\r\n            >\r\n              ⏮️ Start\r\n            </button>\r\n            <button\r\n              onClick={() => jumpToTimepoint(currentTimepoint - 1)}\r\n              disabled={currentTimepoint === 0 || isSimulationRunning}\r\n              style={{ ...buttonVariants.secondaryButton, padding: '4px 8px' }}\r\n            >\r\n              ⏪ Previous\r\n            </button>\r\n            <button\r\n              onClick={() => jumpToTimepoint(currentTimepoint + 1)}\r\n              disabled={currentTimepoint >= dropletHistory.length - 1 || isSimulationRunning}\r\n              style={{ ...buttonVariants.secondaryButton, padding: '4px 8px' }}\r\n            >\r\n              Next ⏩\r\n            </button>\r\n            <button\r\n              onClick={() => jumpToTimepoint(dropletHistory.length - 1)}\r\n              disabled={currentTimepoint >= dropletHistory.length - 1 || isSimulationRunning}\r\n              style={{ ...buttonVariants.secondaryButton, padding: '4px 8px' }}\r\n            >\r\n              End ⏭️\r\n            </button>\r\n          </div>\r\n\r\n          <div style={styles.timeScaleContainer}>\r\n            <label style={{ color: '#fff', marginRight: '10px' }}>\r\n              Time Scale:\r\n              <select\r\n                value={timeScale}\r\n                onChange={(e) => setTimeScale(Number(e.target.value))}\r\n                style={styles.timeInput}\r\n              >\r\n                <option value={0.0625}>1/16x</option>\r\n                <option value={0.25}>1/4x</option>\r\n                <option value={1}>1x</option>\r\n                <option value={4}>4x</option>\r\n                <option value={16}>16x</option>\r\n                <option value={64}>64x</option>\r\n                <option value={256}>256x</option>\r\n                <option value={1024}>1024x</option>\r\n              </select>\r\n            </label>\r\n            <label style={{ color: '#fff', marginRight: '10px' }}>\r\n              Current Time: {currentTime.toFixed(2)}s\r\n            </label>\r\n            <label style={{ color: '#fff' }}>\r\n              Step: {currentTimepoint + 1}/{dropletHistory.length}\r\n            </label>\r\n          </div>\r\n        </div>\r\n      </div>\r\n\r\n      <div style={styles.buttonGroup}>\r\n        <button \r\n          onClick={isSimulationRunning ? stopSimulation : startSimulation} \r\n          style={{ ...buttonVariants.primaryButton }}\r\n        >\r\n          {isSimulationRunning ? 'Stop Simulation' : 'Start Simulation'}\r\n        </button>\r\n        <button \r\n          onClick={restartSimulation} \r\n          style={{ ...buttonVariants.secondaryButton }}\r\n        >\r\n          Restart simulation\r\n        </button>\r\n        <button \r\n          onClick={sendingEventsToDevices} \r\n          style={{ ...buttonVariants.primaryButton }}\r\n        >\r\n          Send Events to Devices\r\n        </button>\r\n        <div ref={displayMenuRef} style={{ position: 'relative', display: 'inline-block' }}>\r\n          <button \r\n            onClick={toggleDisplayMenu} \r\n            style={styles.displayMenuButton}\r\n          >\r\n            Display Settings\r\n          </button>\r\n          {isDisplayMenuOpen && (\r\n            <div style={styles.displayMenu}>\r\n              <div \r\n                style={styles.menuItem}\r\n                onClick={toggleNodeIds}\r\n              >\r\n                <span>Show Node IDs</span>\r\n                <span style={styles.checkmark}>{displayNodeIds ? '✓' : ''}</span>\r\n              </div>\r\n              <div \r\n                style={styles.menuItem}\r\n                onClick={toggleDropletInfo}\r\n              >\r\n                <span>Show Droplet Info</span>\r\n                <span style={styles.checkmark}>{displayDropletInfo ? '✓' : ''}</span>\r\n              </div>\r\n              <div \r\n                style={styles.menuItem}\r\n                onClick={toggleDropletGaps}\r\n              >\r\n                <span>Show Droplet Gaps</span>\r\n                <span style={styles.checkmark}>{displayDropletGaps ? '✓' : ''}</span>\r\n              </div>\r\n              <div \r\n                style={styles.menuItem}\r\n                onClick={toggleEdgeLabels}\r\n              >\r\n                <span>Show Tube Dimensions</span>\r\n                <span style={styles.checkmark}>{displayEdgeLabels ? '✓' : ''}</span>\r\n              </div>\r\n              <div \r\n                style={styles.menuItem}\r\n                onClick={togglePumpSpeeds}\r\n              >\r\n                <span>Show Pump Speeds</span>\r\n                <span style={styles.checkmark}>{displayPumpSpeeds ? '✓' : ''}</span>\r\n              </div>\r\n              <div \r\n                style={styles.menuItem}\r\n                onClick={toggleTimelineDropletInfo}\r\n              >\r\n                <span>Show Timeline Droplet Info</span>\r\n                <span style={styles.checkmark}>{displayTimelineDropletInfo ? '✓' : ''}</span>\r\n              </div>\r\n            </div>\r\n          )}\r\n        </div>\r\n      </div>\r\n\r\n      {/* Rest of the SVG rendering code */}\r\n      {graphData.nodes.length > 0 && (\r\n        <div style={styles.svgContainer}>\r\n          <svg width=\"2000\" height=\"400\">\r\n            {/* Render edges first (background) */}\r\n            {graphData.links.map((link, index) => {\r\n              const sourceNode = graphData.nodes.find(node => node.id === link.source);\r\n              const targetNode = graphData.nodes.find(node => node.id === link.target);\r\n              if (!sourceNode || !targetNode) return null;\r\n              \r\n              const midX = (sourceNode.x + targetNode.x) / 2;\r\n              const midY = (sourceNode.y + targetNode.y) / 2;\r\n              \r\n              return (\r\n                <g key={`edge-${index}`}>\r\n                  <line\r\n                    x1={sourceNode.x}\r\n                    y1={sourceNode.y}\r\n                    x2={targetNode.x}\r\n                    y2={targetNode.y}\r\n                    stroke=\"#999\"\r\n                    strokeWidth={2}\r\n                  />\r\n                  <text\r\n                    x={midX}\r\n                    y={midY - 20}\r\n                    textAnchor=\"middle\"\r\n                    fill=\"#fff\"\r\n                    fontSize=\"12px\"\r\n                    style={{ display: displayEdgeLabels ? 'block' : 'none' }}\r\n                  >\r\n                    {`${link.length} mm (Ø ${link.diameter} mm)`}\r\n                  </text>\r\n                </g>\r\n              );\r\n            })}\r\n\r\n            {/* Render nodes (on top) */}\r\n            {graphData.nodes.map((node, index) => (\r\n              <g key={`node-${index}`}>\r\n                <circle\r\n                  cx={node.x}\r\n                  cy={node.y}\r\n                  r={15}\r\n                  fill={getNodeColor(node)}\r\n                  stroke={selectedNode && selectedNode.id === node.id ? '#FFA500' : 'none'}\r\n                  strokeWidth={selectedNode && selectedNode.id === node.id ? '3' : '0'}\r\n                  onClick={() => handleNodeClick(node)}\r\n                  style={{ cursor: 'pointer' }}\r\n                />\r\n                <text\r\n                  x={node.x}\r\n                  y={node.y - 25}\r\n                  textAnchor=\"middle\"\r\n                  fill=\"#fff\"\r\n                  fontSize=\"12px\"\r\n                >\r\n                  {node.label}\r\n                </text>\r\n                <text\r\n                  x={node.x}\r\n                  y={node.y - 10}\r\n                  textAnchor=\"middle\"\r\n                  fill=\"#fff\"\r\n                  fontSize=\"10px\"\r\n                  style={{ display: displayNodeIds ? 'block' : 'none' }}\r\n                >\r\n                  {`ID: ${node.id}`}\r\n                </text>\r\n              </g>\r\n            ))}\r\n\r\n            {/* Render droplets and distances between them */}\r\n            {interpolateDropletState(currentTime).map((droplet, index, droplets) => {\r\n              const frontX = volumetricToXPosition(droplet.frontVolumetricPosition);\r\n              const rearX = volumetricToXPosition(droplet.rearVolumetricPosition);\r\n              const centerX = (frontX + rearX) / 2;\r\n              \r\n              // Calculate distance to next droplet if this isn't the last droplet\r\n              const distanceInfo = index < droplets.length - 1 ? {\r\n                nextDropletFront: droplets[index + 1].frontVolumetricPosition,\r\n                distance: Math.abs(droplets[index + 1].frontVolumetricPosition - droplet.rearVolumetricPosition)\r\n              } : null;\r\n              \r\n              // Calculate midpoint for distance label\r\n              const distanceLabelX = distanceInfo ? \r\n                (volumetricToXPosition(droplet.rearVolumetricPosition) + \r\n                 volumetricToXPosition(distanceInfo.nextDropletFront)) / 2 : null;\r\n\r\n              return (\r\n                <g key={`droplet-${droplet.id}`}>\r\n                  {/* Droplet body */}\r\n                  <line\r\n                    x1={rearX}\r\n                    y1={300}\r\n                    x2={frontX}\r\n                    y2={300}\r\n                    stroke=\"rgba(255, 100, 100, 0.9)\"\r\n                    strokeWidth={8}\r\n                    strokeLinecap=\"butt\"\r\n                  />\r\n                  \r\n                  {/* Distance to next droplet */}\r\n                  {distanceInfo && displayDropletGaps && (\r\n                    <g>\r\n                      {/* Distance line */}\r\n                      <line\r\n                        x1={rearX}\r\n                        y1={320}\r\n                        x2={volumetricToXPosition(distanceInfo.nextDropletFront)}\r\n                        y2={320}\r\n                        stroke=\"#fff\"\r\n                        strokeWidth={1}\r\n                        strokeDasharray=\"5,5\"\r\n                      />\r\n                      {/* Distance arrows */}\r\n                      <line\r\n                        x1={rearX}\r\n                        y1={315}\r\n                        x2={rearX}\r\n                        y2={325}\r\n                        stroke=\"#fff\"\r\n                        strokeWidth={1}\r\n                      />\r\n                      <line\r\n                        x1={volumetricToXPosition(distanceInfo.nextDropletFront)}\r\n                        y1={315}\r\n                        x2={volumetricToXPosition(distanceInfo.nextDropletFront)}\r\n                        y2={325}\r\n                        stroke=\"#666\"\r\n                        strokeWidth={1}\r\n                      />\r\n                      {/* Distance label */}\r\n                      <text\r\n                        x={distanceLabelX}\r\n                        y={335}\r\n                        textAnchor=\"middle\"\r\n                        fill=\"#666\"\r\n                        fontSize=\"12px\"\r\n                      >\r\n                        {`${distanceInfo.distance.toFixed(2)} μL`}\r\n                      </text>\r\n                    </g>\r\n                  )}\r\n                  \r\n                  {/* Droplet info - wrap all info texts in conditional rendering */}\r\n                  {displayDropletInfo && (\r\n                    <>\r\n                      <text\r\n                        x={centerX}\r\n                        y={270}\r\n                        textAnchor=\"middle\"\r\n                        fill=\"#6f6\"\r\n                        fontSize=\"12px\"\r\n                      >\r\n                        {`Vol: ${(droplet.frontVolumetricPosition-droplet.rearVolumetricPosition).toFixed(2)} μL`}\r\n                      </text>\r\n                      <text\r\n                        x={centerX}\r\n                        y={255}\r\n                        textAnchor=\"middle\"\r\n                        fill=\"#6f6\"\r\n                        fontSize=\"12px\"\r\n                      >\r\n                        {`Spd f: ${droplet.frontVolumetricSpeed.toFixed(2)} μL/s`}\r\n                      </text>\r\n                      <text\r\n                        x={centerX}\r\n                        y={240}\r\n                        textAnchor=\"middle\"\r\n                        fill=\"#6f6\"\r\n                        fontSize=\"12px\"\r\n                      >\r\n                        {`Spd r: ${droplet.rearVolumetricSpeed.toFixed(2)} μL/s`}\r\n                      </text>\r\n                      <text\r\n                        x={centerX}\r\n                        y={225}\r\n                        textAnchor=\"middle\"\r\n                        fill=\"#6f6\"\r\n                        fontSize=\"12px\"\r\n                      >\r\n                        {`mlt: ${droplet.pumpSpeedMultiplier.toFixed(2)}`}\r\n                      </text>\r\n                    </>\r\n                  )}\r\n                </g>\r\n              );\r\n            })}\r\n\r\n            {displayPumpSpeeds && graphData.nodes.map((node, index) => {\r\n              if (node.type === 'pump') {\r\n                const currentSpeed = getPumpSpeedAtTime(node.id, pumpEvents, currentTime);\r\n                const maxTime = dropletHistory[dropletHistory.length - 1]?.time || 1;\r\n                const pumpSpecificEvents = pumpEvents.filter(event => event.target === node.id);\r\n                \r\n                return (\r\n                  <g key={`pump-speed-${node.id}`}>\r\n                    {/* Current pump speed value */}\r\n                    <text\r\n                      x={node.x}\r\n                      y={node.y - 35}\r\n                      textAnchor=\"middle\"\r\n                      fill=\"#4CAF50\"\r\n                      fontSize=\"12px\"\r\n                    >\r\n                      {`${currentSpeed.toFixed(2)} μL/s`}\r\n                    </text>\r\n                    \r\n                    {/* Speed history visualization */}\r\n                    <g transform={`translate(${node.x - 40}, ${node.y - 65})`}>\r\n                      {pumpSpecificEvents.map((event, i, arr) => {\r\n                        const nextEvent = arr[i + 1];\r\n                        const width = 80;\r\n                        const x = 0;\r\n                        const y = 0;\r\n                        \r\n                        // Calculate position based on time\r\n                        const timePosition = (event.time / maxTime) * width;\r\n                        const nextTimePosition = nextEvent \r\n                          ? (nextEvent.time / maxTime) * width\r\n                          : width;\r\n                        \r\n                        // Calculate height based on speed value (normalized)\r\n                        const maxSpeed = Math.max(...pumpSpecificEvents.map(e => e.value));\r\n                        const normalizedHeight = event.value / (maxSpeed || 1) * 20;\r\n                        \r\n                        return (\r\n                          <g key={`pump-event-${i}`}>\r\n                            {/* Speed segment */}\r\n                            <line\r\n                              x1={x + timePosition}\r\n                              y1={y - normalizedHeight}\r\n                              x2={x + nextTimePosition}\r\n                              y2={y - normalizedHeight}\r\n                              stroke=\"#4CAF50\"\r\n                              strokeWidth={2}\r\n                            />\r\n                            {/* Event point */}\r\n                            <circle\r\n                              cx={x + timePosition}\r\n                              cy={y - normalizedHeight}\r\n                              r={2}\r\n                              fill=\"#4CAF50\"\r\n                            />\r\n                            {/* Time marker */}\r\n                            <text\r\n                              x={x + timePosition}\r\n                              y={y + 12}\r\n                              textAnchor=\"middle\"\r\n                              fill=\"#666\"\r\n                              fontSize=\"10px\"\r\n                            >\r\n                              {event.time.toFixed(1)}s\r\n                            </text>\r\n                            {/* Speed value */}\r\n                            <text\r\n                              x={x + timePosition}\r\n                              y={y - normalizedHeight - 5}\r\n                              textAnchor=\"middle\"\r\n                              fill=\"#4CAF50\"\r\n                              fontSize=\"8px\"\r\n                            >\r\n                              {event.value.toFixed(1)}\r\n                            </text>\r\n                          </g>\r\n                        );\r\n                      })}\r\n                      {/* Current time indicator */}\r\n                      <line\r\n                        x1={(currentTime / maxTime) * 80}\r\n                        y1={-25}\r\n                        x2={(currentTime / maxTime) * 80}\r\n                        y2={15}\r\n                        stroke=\"red\"\r\n                        strokeWidth={1}\r\n                        strokeDasharray=\"2,2\"\r\n                      />\r\n                    </g>\r\n                  </g>\r\n                );\r\n              }\r\n              return null;\r\n            })}\r\n          </svg>\r\n        </div>\r\n      )}\r\n      \r\n      {selectedNode && (selectedNode.type === 'pump' || selectedNode.data?.type === 'pump') && (\r\n        <DraggablePanel \r\n          initialPosition={pumpPanelPosition}\r\n          title={`Pump Controls - ${selectedNode.label || selectedNode.id}`}\r\n        >\r\n          <PumpActions\r\n            node={selectedNode}\r\n            nodes={nodes}\r\n            edges={edges}\r\n            onAction={handleNodeAction}\r\n          />\r\n        </DraggablePanel>\r\n      )}\r\n      {selectedNode && (selectedNode.type === 'USBSpectrometer' || selectedNode.data?.type === 'USBSpectrometer') && (\r\n        <>\r\n          {console.log('Rendering USBSpectrometer component for node:', selectedNode)}\r\n          <USBSpectrometer\r\n            detector={selectedNode}\r\n            detectorId={selectedNode.id}\r\n            detectorName={selectedNode.label || selectedNode.id}\r\n            onClose={() => setSelectedNode(null)}\r\n            initialPosition={{ x: 150, y: 100 }}\r\n            isVisible={true}\r\n          />\r\n        </>\r\n      )}\r\n      {selectedNode && (selectedNode.type === 'MQTTSpectrometer' || selectedNode.data?.type === 'MQTTSpectrometer') && (\r\n        <>\r\n          {console.log('Rendering SpectrometerMQTT component for node:', selectedNode)}\r\n          <SpectrometerMQTT\r\n            detector={selectedNode}\r\n            detectorId={selectedNode.id}\r\n            detectorName={selectedNode.label || selectedNode.id}\r\n            onClose={() => setSelectedNode(null)}\r\n            initialPosition={{ x: 150, y: 100 }}\r\n            isVisible={true}\r\n          />\r\n        </>\r\n      )}\r\n      {/* Add styles for PumpActions */}\r\n      <style>\r\n        {`\r\n          .node-actions {\r\n            position: fixed;\r\n            top: 20px;\r\n            right: 20px;\r\n            background: black;\r\n            padding: 20px;\r\n            border: 1px solid #ccc;\r\n            border-radius: 5px;\r\n            box-shadow: 0 2px 4px rgba(0,0,0,0.1);\r\n          }\r\n          .node-actions h3 {\r\n            margin: 0 0 15px 0;\r\n            color: #333;\r\n          }\r\n          .node-actions button {\r\n            margin: 5px;\r\n            padding: 8px 16px;\r\n            background: #4CAF50;\r\n            color: white;\r\n            border: none;\r\n            border-radius: 4px;\r\n            cursor: pointer;\r\n          }\r\n          .node-actions button:disabled {\r\n            background: #ccc;\r\n            cursor: not-allowed;\r\n          }\r\n          .node-actions input {\r\n            margin: 5px;\r\n            padding: 8px;\r\n            border: 1px solid #ccc;\r\n            border-radius: 4px;\r\n            width: 80px;\r\n          }\r\n          .move-controls {\r\n            display: flex;\r\n            flex-direction: column;\r\n            gap: 10px;\r\n            margin-top: 10px;\r\n          }\r\n          .input-group {\r\n            display: flex;\r\n            align-items: center;\r\n            gap: 10px;\r\n          }\r\n          .input-group label {\r\n            min-width: 100px;\r\n            text-align: right;\r\n            color: #666;\r\n          }\r\n        `}\r\n      </style>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Simulation;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}