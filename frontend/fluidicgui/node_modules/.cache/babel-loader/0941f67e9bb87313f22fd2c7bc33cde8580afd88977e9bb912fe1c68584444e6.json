{"ast":null,"code":"/**\r\n * Utility functions for flowchart operations\r\n */\n\n/**\r\n * Calculates the start and end points for an edge between two nodes\r\n * @param {Object} sourceNode - The source node object\r\n * @param {Object} targetNode - The target node object\r\n * @returns {Object} Object with sourceX, sourceY, targetX, targetY coordinates\r\n */\nexport const calculateEdgePoints = (sourceNode, targetNode) => {\n  if (!sourceNode || !targetNode) {\n    console.warn('Missing node data for edge calculation');\n    return {\n      sourceX: 0,\n      sourceY: 0,\n      targetX: 0,\n      targetY: 0\n    };\n  }\n  const sourceX = sourceNode.position.x + sourceNode.width;\n  const sourceY = sourceNode.position.y + sourceNode.height / 2;\n  const targetX = targetNode.position.x;\n  const targetY = targetNode.position.y + targetNode.height / 2;\n  return {\n    sourceX,\n    sourceY,\n    targetX,\n    targetY\n  };\n};\n\n/**\r\n * Creates labels for edges based on node and edge data\r\n * @param {Array} nodes - Array of node objects\r\n * @param {Array} edges - Array of edge objects\r\n * @returns {Array} Updated edges with label information\r\n */\nexport const createLabels = (nodes, edges) => {\n  if (!nodes || !edges) {\n    console.warn('Missing nodes or edges data for label creation');\n    return [];\n  }\n  return edges.map(edge => {\n    const sourceNode = nodes.find(node => node.id === edge.source);\n    const targetNode = nodes.find(node => node.id === edge.target);\n    if (!sourceNode || !targetNode) {\n      console.warn(`Could not find nodes for edge ${edge.id}`);\n      return edge;\n    }\n\n    // Calculate the midpoint for the label\n    const {\n      sourceX,\n      sourceY,\n      targetX,\n      targetY\n    } = calculateEdgePoints(sourceNode, targetNode);\n    const labelX = (sourceX + targetX) / 2;\n    const labelY = (sourceY + targetY) / 2 - 10; // Offset above the line\n\n    // Create a label based on node types or other logic\n    let labelText = '';\n    if (sourceNode.type === 'pump') {\n      var _sourceNode$data;\n      labelText = `Flow: ${((_sourceNode$data = sourceNode.data) === null || _sourceNode$data === void 0 ? void 0 : _sourceNode$data.flowRate) || '?'} μL/s`;\n    } else if (sourceNode.type === 'thermostat') {\n      var _sourceNode$data2;\n      labelText = `${((_sourceNode$data2 = sourceNode.data) === null || _sourceNode$data2 === void 0 ? void 0 : _sourceNode$data2.temperature) || '?'}°C`;\n    }\n    return {\n      ...edge,\n      labelX,\n      labelY,\n      labelText\n    };\n  });\n};\n\n/**\r\n * Calculates the path for a curved edge between nodes\r\n * @param {Object} sourceNode - The source node\r\n * @param {Object} targetNode - The target node\r\n * @returns {String} SVG path string\r\n */\nexport const calculateEdgePath = (sourceNode, targetNode) => {\n  if (!sourceNode || !targetNode) {\n    return '';\n  }\n  const {\n    sourceX,\n    sourceY,\n    targetX,\n    targetY\n  } = calculateEdgePoints(sourceNode, targetNode);\n\n  // Calculate control points for a smooth curve\n  const controlPointX1 = sourceX + Math.abs(targetX - sourceX) / 3;\n  const controlPointX2 = targetX - Math.abs(targetX - sourceX) / 3;\n  return `M ${sourceX} ${sourceY} C ${controlPointX1} ${sourceY}, ${controlPointX2} ${targetY}, ${targetX} ${targetY}`;\n};\n\n/**\r\n * Finds the shortest path between two nodes in a graph\r\n * @param {Array} nodes - Array of all nodes\r\n * @param {Array} edges - Array of all edges\r\n * @param {String} startNodeId - ID of the start node\r\n * @param {String} endNodeId - ID of the end node\r\n * @returns {Array} Array of node IDs representing the path\r\n */\nexport const findShortestPath = (nodes, edges, startNodeId, endNodeId) => {\n  // Build adjacency list\n  const adjacencyList = {};\n  nodes.forEach(node => {\n    adjacencyList[node.id] = [];\n  });\n  edges.forEach(edge => {\n    adjacencyList[edge.source].push(edge.target);\n  });\n\n  // BFS for shortest path\n  const queue = [[startNodeId]];\n  const visited = new Set();\n  while (queue.length > 0) {\n    const path = queue.shift();\n    const currentNodeId = path[path.length - 1];\n    if (currentNodeId === endNodeId) {\n      return path;\n    }\n    if (!visited.has(currentNodeId)) {\n      visited.add(currentNodeId);\n      const neighbors = adjacencyList[currentNodeId] || [];\n      for (const neighbor of neighbors) {\n        const newPath = [...path, neighbor];\n        queue.push(newPath);\n      }\n    }\n  }\n  return []; // No path found\n};","map":{"version":3,"names":["calculateEdgePoints","sourceNode","targetNode","console","warn","sourceX","sourceY","targetX","targetY","position","x","width","y","height","createLabels","nodes","edges","map","edge","find","node","id","source","target","labelX","labelY","labelText","type","_sourceNode$data","data","flowRate","_sourceNode$data2","temperature","calculateEdgePath","controlPointX1","Math","abs","controlPointX2","findShortestPath","startNodeId","endNodeId","adjacencyList","forEach","push","queue","visited","Set","length","path","shift","currentNodeId","has","add","neighbors","neighbor","newPath"],"sources":["E:/flow chemistry/fluidicGUI/frontend/fluidicgui/src/utils/flowchartUtils.js"],"sourcesContent":["/**\r\n * Utility functions for flowchart operations\r\n */\r\n\r\n/**\r\n * Calculates the start and end points for an edge between two nodes\r\n * @param {Object} sourceNode - The source node object\r\n * @param {Object} targetNode - The target node object\r\n * @returns {Object} Object with sourceX, sourceY, targetX, targetY coordinates\r\n */\r\nexport const calculateEdgePoints = (sourceNode, targetNode) => {\r\n  if (!sourceNode || !targetNode) {\r\n    console.warn('Missing node data for edge calculation');\r\n    return { sourceX: 0, sourceY: 0, targetX: 0, targetY: 0 };\r\n  }\r\n\r\n  const sourceX = sourceNode.position.x + sourceNode.width;\r\n  const sourceY = sourceNode.position.y + sourceNode.height / 2;\r\n  const targetX = targetNode.position.x;\r\n  const targetY = targetNode.position.y + targetNode.height / 2;\r\n\r\n  return { sourceX, sourceY, targetX, targetY };\r\n};\r\n\r\n/**\r\n * Creates labels for edges based on node and edge data\r\n * @param {Array} nodes - Array of node objects\r\n * @param {Array} edges - Array of edge objects\r\n * @returns {Array} Updated edges with label information\r\n */\r\nexport const createLabels = (nodes, edges) => {\r\n  if (!nodes || !edges) {\r\n    console.warn('Missing nodes or edges data for label creation');\r\n    return [];\r\n  }\r\n\r\n  return edges.map(edge => {\r\n    const sourceNode = nodes.find(node => node.id === edge.source);\r\n    const targetNode = nodes.find(node => node.id === edge.target);\r\n    \r\n    if (!sourceNode || !targetNode) {\r\n      console.warn(`Could not find nodes for edge ${edge.id}`);\r\n      return edge;\r\n    }\r\n\r\n    // Calculate the midpoint for the label\r\n    const { sourceX, sourceY, targetX, targetY } = calculateEdgePoints(sourceNode, targetNode);\r\n    const labelX = (sourceX + targetX) / 2;\r\n    const labelY = (sourceY + targetY) / 2 - 10; // Offset above the line\r\n    \r\n    // Create a label based on node types or other logic\r\n    let labelText = '';\r\n    if (sourceNode.type === 'pump') {\r\n      labelText = `Flow: ${sourceNode.data?.flowRate || '?'} μL/s`;\r\n    } else if (sourceNode.type === 'thermostat') {\r\n      labelText = `${sourceNode.data?.temperature || '?'}°C`;\r\n    }\r\n    \r\n    return {\r\n      ...edge,\r\n      labelX,\r\n      labelY,\r\n      labelText\r\n    };\r\n  });\r\n};\r\n\r\n/**\r\n * Calculates the path for a curved edge between nodes\r\n * @param {Object} sourceNode - The source node\r\n * @param {Object} targetNode - The target node\r\n * @returns {String} SVG path string\r\n */\r\nexport const calculateEdgePath = (sourceNode, targetNode) => {\r\n  if (!sourceNode || !targetNode) {\r\n    return '';\r\n  }\r\n  \r\n  const { sourceX, sourceY, targetX, targetY } = calculateEdgePoints(sourceNode, targetNode);\r\n  \r\n  // Calculate control points for a smooth curve\r\n  const controlPointX1 = sourceX + Math.abs(targetX - sourceX) / 3;\r\n  const controlPointX2 = targetX - Math.abs(targetX - sourceX) / 3;\r\n  \r\n  return `M ${sourceX} ${sourceY} C ${controlPointX1} ${sourceY}, ${controlPointX2} ${targetY}, ${targetX} ${targetY}`;\r\n};\r\n\r\n/**\r\n * Finds the shortest path between two nodes in a graph\r\n * @param {Array} nodes - Array of all nodes\r\n * @param {Array} edges - Array of all edges\r\n * @param {String} startNodeId - ID of the start node\r\n * @param {String} endNodeId - ID of the end node\r\n * @returns {Array} Array of node IDs representing the path\r\n */\r\nexport const findShortestPath = (nodes, edges, startNodeId, endNodeId) => {\r\n  // Build adjacency list\r\n  const adjacencyList = {};\r\n  \r\n  nodes.forEach(node => {\r\n    adjacencyList[node.id] = [];\r\n  });\r\n  \r\n  edges.forEach(edge => {\r\n    adjacencyList[edge.source].push(edge.target);\r\n  });\r\n  \r\n  // BFS for shortest path\r\n  const queue = [[startNodeId]];\r\n  const visited = new Set();\r\n  \r\n  while (queue.length > 0) {\r\n    const path = queue.shift();\r\n    const currentNodeId = path[path.length - 1];\r\n    \r\n    if (currentNodeId === endNodeId) {\r\n      return path;\r\n    }\r\n    \r\n    if (!visited.has(currentNodeId)) {\r\n      visited.add(currentNodeId);\r\n      \r\n      const neighbors = adjacencyList[currentNodeId] || [];\r\n      for (const neighbor of neighbors) {\r\n        const newPath = [...path, neighbor];\r\n        queue.push(newPath);\r\n      }\r\n    }\r\n  }\r\n  \r\n  return []; // No path found\r\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}